{"version":3,"file":"slate.es.js","sources":["../src/constants/model-types.js","../src/utils/generate-key.js","../src/models/block.js","../src/models/inline.js","../src/models/data.js","../src/utils/memoize.js","../src/models/mark.js","../src/changes/at-current-range.js","../src/models/document.js","../src/models/range.js","../src/models/character.js","../src/models/leaf.js","../src/models/text.js","../src/models/node.js","../src/utils/string.js","../src/changes/at-range.js","../src/changes/by-key.js","../src/constants/operation-attributes.js","../src/models/history.js","../src/constants/core-schema-rules.js","../src/models/stack.js","../src/models/schema.js","../src/models/value.js","../src/models/operation.js","../src/operations/invert.js","../src/changes/on-history.js","../src/changes/on-selection.js","../src/changes/on-value.js","../src/changes/with-schema.js","../src/changes/index.js","../src/operations/apply.js","../src/models/change.js","../src/operations/index.js","../src/index.js"],"sourcesContent":["/**\n * Slate-specific model types.\n *\n * @type {Object}\n */\n\nconst MODEL_TYPES = {\n  BLOCK: '@@__SLATE_BLOCK__@@',\n  CHANGE: '@@__SLATE_CHANGE__@@',\n  CHARACTER: '@@__SLATE_CHARACTER__@@',\n  DOCUMENT: '@@__SLATE_DOCUMENT__@@',\n  HISTORY: '@@__SLATE_HISTORY__@@',\n  INLINE: '@@__SLATE_INLINE__@@',\n  LEAF: '@@__SLATE_LEAF__@@',\n  MARK: '@@__SLATE_MARK__@@',\n  OPERATION: '@@__SLATE_OPERATION__@@',\n  RANGE: '@@__SLATE_RANGE__@@',\n  SCHEMA: '@@__SLATE_SCHEMA__@@',\n  STACK: '@@__SLATE_STACK__@@',\n  TEXT: '@@__SLATE_TEXT__@@',\n  VALUE: '@@__SLATE_VALUE__@@',\n}\n\n/**\n * Export type identification function\n *\n * @param {string} type\n * @param {any} any\n * @return {boolean}\n */\n\nexport function isType(type, any) {\n  return !!(any && any[MODEL_TYPES[type]])\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default MODEL_TYPES\n","/**\n * An auto-incrementing index for generating keys.\n *\n * @type {Number}\n */\n\nlet n\n\n/**\n * The global key generating function.\n *\n * @type {Function}\n */\n\nlet generate\n\n/**\n * Generate a key.\n *\n * @return {String}\n */\n\nfunction generateKey() {\n  return generate()\n}\n\n/**\n * Set a different unique ID generating `function`.\n *\n * @param {Function} func\n */\n\nfunction setKeyGenerator(func) {\n  generate = func\n}\n\n/**\n * Reset the key generating function to its initial state.\n */\n\nfunction resetKeyGenerator() {\n  n = 0\n  generate = () => `${n++}`\n}\n\n/**\n * Set the initial state.\n */\n\nresetKeyGenerator()\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default generateKey\nexport { setKeyGenerator, resetKeyGenerator }\n","/**\n * Dependencies.\n */\n\nimport isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport { List, Map, Record } from 'immutable'\n\nimport MODEL_TYPES, { isType } from '../constants/model-types'\nimport generateKey from '../utils/generate-key'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: new Map(),\n  isVoid: false,\n  key: undefined,\n  nodes: new List(),\n  type: undefined,\n}\n\n/**\n * Block.\n *\n * @type {Block}\n */\n\nclass Block extends Record(DEFAULTS) {\n  /**\n   * Create a new `Block` from `attrs`.\n   *\n   * @param {Object|String|Block} attrs\n   * @return {Block}\n   */\n\n  static create(attrs = {}) {\n    if (Block.isBlock(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs == 'string') {\n      attrs = { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Block.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Block.create\\` only accepts objects, strings or blocks, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Blocks` from `attrs`.\n   *\n   * @param {Array<Block|Object>|List<Block|Object>} attrs\n   * @return {List<Block>}\n   */\n\n  static createList(attrs = []) {\n    if (List.isList(attrs) || Array.isArray(attrs)) {\n      const list = new List(attrs.map(Block.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Block.createList\\` only accepts arrays or lists, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Block` from a JSON `object`.\n   *\n   * @param {Object|Block} object\n   * @return {Block}\n   */\n\n  static fromJSON(object) {\n    if (Block.isBlock(object)) {\n      return object\n    }\n\n    const {\n      data = {},\n      isVoid = false,\n      key = generateKey(),\n      nodes = [],\n      type,\n    } = object\n\n    if (typeof type != 'string') {\n      throw new Error('`Block.fromJSON` requires a `type` string.')\n    }\n\n    const block = new Block({\n      key,\n      type,\n      isVoid: !!isVoid,\n      data: Map(data),\n      nodes: Block.createChildren(nodes),\n    })\n\n    return block\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Block.fromJSON\n\n  /**\n   * Check if `any` is a `Block`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isBlock = isType.bind(null, 'BLOCK')\n\n  /**\n   * Check if `any` is a block list.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isBlockList(any) {\n    return List.isList(any) && any.every(item => Block.isBlock(item))\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'block'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Check if the block is empty.\n   * Returns true if block is not void and all it's children nodes are empty.\n   * Void node is never empty, regardless of it's content.\n   *\n   * @return {Boolean}\n   */\n\n  get isEmpty() {\n    return !this.isVoid && !this.nodes.some(child => !child.isEmpty)\n  }\n\n  /**\n   * Get the concatenated text of all the block's children.\n   *\n   * @return {String}\n   */\n\n  get text() {\n    return this.getText()\n  }\n\n  /**\n   * Return a JSON representation of the block.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      type: this.type,\n      isVoid: this.isVoid,\n      data: this.data.toJSON(),\n      nodes: this.nodes.toArray().map(n => n.toJSON(options)),\n    }\n\n    if (options.preserveKeys) {\n      object.key = this.key\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS(options) {\n    return this.toJSON(options)\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nBlock.prototype[MODEL_TYPES.BLOCK] = true\n\n/**\n * Export.\n *\n * @type {Block}\n */\n\nexport default Block\n","/**\n * Dependencies.\n */\n\nimport isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport { List, Map, Record } from 'immutable'\n\nimport MODEL_TYPES, { isType } from '../constants/model-types'\nimport generateKey from '../utils/generate-key'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: new Map(),\n  isVoid: false,\n  key: undefined,\n  nodes: new List(),\n  type: undefined,\n}\n\n/**\n * Inline.\n *\n * @type {Inline}\n */\n\nclass Inline extends Record(DEFAULTS) {\n  /**\n   * Create a new `Inline` with `attrs`.\n   *\n   * @param {Object|String|Inline} attrs\n   * @return {Inline}\n   */\n\n  static create(attrs = {}) {\n    if (Inline.isInline(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs == 'string') {\n      attrs = { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Inline.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Inline.create\\` only accepts objects, strings or inlines, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Inlines` from an array.\n   *\n   * @param {Array<Inline|Object>|List<Inline|Object>} elements\n   * @return {List<Inline>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Inline.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Inline.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a `Inline` from a JSON `object`.\n   *\n   * @param {Object|Inline} object\n   * @return {Inline}\n   */\n\n  static fromJSON(object) {\n    if (Inline.isInline(object)) {\n      return object\n    }\n\n    const {\n      data = {},\n      isVoid = false,\n      key = generateKey(),\n      nodes = [],\n      type,\n    } = object\n\n    if (typeof type != 'string') {\n      throw new Error('`Inline.fromJS` requires a `type` string.')\n    }\n\n    const inline = new Inline({\n      key,\n      type,\n      isVoid: !!isVoid,\n      data: new Map(data),\n      nodes: Inline.createChildren(nodes),\n    })\n\n    return inline\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Inline.fromJSON\n\n  /**\n   * Check if `any` is a `Inline`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isInline = isType.bind(null, 'INLINE')\n\n  /**\n   * Check if `any` is a list of inlines.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isInlineList(any) {\n    return List.isList(any) && any.every(item => Inline.isInline(item))\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'inline'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Check if the inline is empty.\n   * Returns true if inline is not void and all it's children nodes are empty.\n   * Void node is never empty, regardless of it's content.\n   *\n   * @return {Boolean}\n   */\n\n  get isEmpty() {\n    return !this.isVoid && !this.nodes.some(child => !child.isEmpty)\n  }\n\n  /**\n   * Get the concatenated text of all the inline's children.\n   *\n   * @return {String}\n   */\n\n  get text() {\n    return this.getText()\n  }\n\n  /**\n   * Return a JSON representation of the inline.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      type: this.type,\n      isVoid: this.isVoid,\n      data: this.data.toJSON(),\n      nodes: this.nodes.toArray().map(n => n.toJSON(options)),\n    }\n\n    if (options.preserveKeys) {\n      object.key = this.key\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS(options) {\n    return this.toJSON(options)\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nInline.prototype[MODEL_TYPES.INLINE] = true\n\n/**\n * Export.\n *\n * @type {Inline}\n */\n\nexport default Inline\n","import isPlainObject from 'is-plain-object'\nimport { Map } from 'immutable'\n\n/**\n * Data.\n *\n * This isn't an immutable record, it's just a thin wrapper around `Map` so that\n * we can allow for more convenient creation.\n *\n * @type {Object}\n */\n\nclass Data {\n  /**\n   * Create a new `Data` with `attrs`.\n   *\n   * @param {Object|Data|Map} attrs\n   * @return {Data} data\n   */\n\n  static create(attrs = {}) {\n    if (Map.isMap(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Data.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Data.create\\` only accepts objects or maps, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Data` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Data}\n   */\n\n  static fromJSON(object) {\n    return new Map(object)\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Data.fromJSON\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Data\n","/**\n * GLOBAL: True if memoization should is enabled.\n *\n * @type {Boolean}\n */\n\nlet ENABLED = true\n\n/**\n * GLOBAL: Changing this cache key will clear all previous cached results.\n *\n * @type {Number}\n */\n\nlet CACHE_KEY = 0\n\n/**\n * The leaf node of a cache tree. Used to support variable argument length. A\n * unique object, so that native Maps will key it by reference.\n *\n * @type {Object}\n */\n\nconst LEAF = {}\n\n/**\n * A value to represent a memoized undefined value. Allows efficient value\n * retrieval using Map.get only.\n *\n * @type {Object}\n */\n\nconst UNDEFINED = {}\n\n/**\n * Default value for unset keys in native Maps\n *\n * @type {Undefined}\n */\n\nconst UNSET = undefined\n\n/**\n * Memoize all of the `properties` on a `object`.\n *\n * @param {Object} object\n * @param {Array} properties\n * @return {Record}\n */\n\nfunction memoize(object, properties) {\n  for (const property of properties) {\n    const original = object[property]\n\n    if (!original) {\n      throw new Error(`Object does not have a property named \"${property}\".`)\n    }\n\n    object[property] = function(...args) {\n      // If memoization is disabled, call into the original method.\n      if (!ENABLED) return original.apply(this, args)\n\n      // If the cache key is different, previous caches must be cleared.\n      if (CACHE_KEY !== this.__cache_key) {\n        this.__cache_key = CACHE_KEY\n        this.__cache = new Map() // eslint-disable-line no-undef,no-restricted-globals\n        this.__cache_no_args = {}\n        this.__cache_no_args.__proto__ = null\n      }\n\n      if (!this.__cache) {\n        this.__cache = new Map() // eslint-disable-line no-undef,no-restricted-globals\n      }\n      if (!this.__cache_no_args) {\n        this.__cache_no_args = {}\n        this.__cache_no_args.__proto__ = null\n      }\n\n      const takesArguments = args.length !== 0\n\n      let cachedValue\n      let keys\n\n      if (takesArguments) {\n        keys = [property, ...args]\n        cachedValue = getIn(this.__cache, keys)\n      } else {\n        cachedValue = this.__cache_no_args[property]\n      }\n\n      // If we've got a result already, return it.\n      if (cachedValue !== UNSET) {\n        return cachedValue === UNDEFINED ? undefined : cachedValue\n      }\n\n      // Otherwise calculate what it should be once and cache it.\n      const value = original.apply(this, args)\n      const v = value === undefined ? UNDEFINED : value\n\n      if (takesArguments) {\n        this.__cache = setIn(this.__cache, keys, v)\n      } else {\n        this.__cache_no_args[property] = v\n      }\n\n      return value\n    }\n  }\n}\n\n/**\n * Get a value at a key path in a tree of Map.\n *\n * If not set, returns UNSET.\n * If the set value is undefined, returns UNDEFINED.\n *\n * @param {Map} map\n * @param {Array} keys\n * @return {Any|UNSET|UNDEFINED}\n */\n\nfunction getIn(map, keys) {\n  for (const key of keys) {\n    map = map.get(key)\n    if (map === UNSET) return UNSET\n  }\n\n  return map.get(LEAF)\n}\n\n/**\n * Set a value at a key path in a tree of Map, creating Maps on the go.\n *\n * @param {Map} map\n * @param {Array} keys\n * @param {Any} value\n * @return {Map}\n */\n\nfunction setIn(map, keys, value) {\n  let parent = map\n  let child\n\n  for (const key of keys) {\n    child = parent.get(key)\n\n    // If the path was not created yet...\n    if (child === UNSET) {\n      child = new Map() // eslint-disable-line no-undef,no-restricted-globals\n      parent.set(key, child)\n    }\n\n    parent = child\n  }\n\n  // The whole path has been created, so set the value to the bottom most map.\n  child.set(LEAF, value)\n  return map\n}\n\n/**\n * In DEV mode, clears the previously memoized values, globally.\n *\n * @return {Void}\n */\n\nfunction resetMemoization() {\n  CACHE_KEY++\n\n  if (CACHE_KEY >= Number.MAX_SAFE_INTEGER) {\n    CACHE_KEY = 0\n  }\n}\n\n/**\n * In DEV mode, enable or disable the use of memoize values, globally.\n *\n * @param {Boolean} enabled\n * @return {Void}\n */\n\nfunction useMemoization(enabled) {\n  ENABLED = enabled\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default memoize\nexport { resetMemoization, useMemoization }\n","import isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport { Map, Record, Set } from 'immutable'\n\nimport MODEL_TYPES, { isType } from '../constants/model-types'\nimport Data from './data'\nimport memoize from '../utils/memoize'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: new Map(),\n  type: undefined,\n}\n\n/**\n * Mark.\n *\n * @type {Mark}\n */\n\nclass Mark extends Record(DEFAULTS) {\n  /**\n   * Create a new `Mark` with `attrs`.\n   *\n   * @param {Object|Mark} attrs\n   * @return {Mark}\n   */\n\n  static create(attrs = {}) {\n    if (Mark.isMark(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs == 'string') {\n      attrs = { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Mark.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Mark.create\\` only accepts objects, strings or marks, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a set of marks.\n   *\n   * @param {Array<Object|Mark>} elements\n   * @return {Set<Mark>}\n   */\n\n  static createSet(elements) {\n    if (Set.isSet(elements) || Array.isArray(elements)) {\n      const marks = new Set(elements.map(Mark.create))\n      return marks\n    }\n\n    if (elements == null) {\n      return new Set()\n    }\n\n    throw new Error(\n      `\\`Mark.createSet\\` only accepts sets, arrays or null, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable mark properties from `attrs`.\n   *\n   * @param {Object|String|Mark} attrs\n   * @return {Object}\n   */\n\n  static createProperties(attrs = {}) {\n    if (Mark.isMark(attrs)) {\n      return {\n        data: attrs.data,\n        type: attrs.type,\n      }\n    }\n\n    if (typeof attrs == 'string') {\n      return { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      const props = {}\n      if ('type' in attrs) props.type = attrs.type\n      if ('data' in attrs) props.data = Data.create(attrs.data)\n      return props\n    }\n\n    throw new Error(\n      `\\`Mark.createProperties\\` only accepts objects, strings or marks, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Mark` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Mark}\n   */\n\n  static fromJSON(object) {\n    const { data = {}, type } = object\n\n    if (typeof type != 'string') {\n      throw new Error('`Mark.fromJS` requires a `type` string.')\n    }\n\n    const mark = new Mark({\n      type,\n      data: new Map(data),\n    })\n\n    return mark\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Mark.fromJSON\n\n  /**\n   * Check if `any` is a `Mark`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isMark = isType.bind(null, 'MARK')\n\n  /**\n   * Check if `any` is a set of marks.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isMarkSet(any) {\n    return Set.isSet(any) && any.every(item => Mark.isMark(item))\n  }\n\n  /**\n   * Object.\n   */\n\n  get object() {\n    return 'mark'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Get the component for the node from a `schema`.\n   *\n   * @param {Schema} schema\n   * @return {Component|Void}\n   */\n\n  getComponent(schema) {\n    return schema.__getComponent(this)\n  }\n\n  /**\n   * Return a JSON representation of the mark.\n   *\n   * @return {Object}\n   */\n\n  toJSON() {\n    const object = {\n      object: this.object,\n      type: this.type,\n      data: this.data.toJSON(),\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS() {\n    return this.toJSON()\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nMark.prototype[MODEL_TYPES.MARK] = true\n\n/**\n * Memoize read methods.\n */\n\nmemoize(Mark.prototype, ['getComponent'])\n\n/**\n * Export.\n *\n * @type {Mark}\n */\n\nexport default Mark\n","import logger from 'slate-dev-logger'\nimport Block from '../models/block'\nimport Inline from '../models/inline'\nimport Mark from '../models/mark'\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nconst Changes = {}\n\n/**\n * Mix in the changes that pass through to their at-range equivalents because\n * they don't have any effect on the selection.\n */\n\nconst PROXY_TRANSFORMS = [\n  'deleteBackward',\n  'deleteCharBackward',\n  'deleteLineBackward',\n  'deleteWordBackward',\n  'deleteForward',\n  'deleteCharForward',\n  'deleteWordForward',\n  'deleteLineForward',\n  'setBlocks',\n  'setInlines',\n  'splitInline',\n  'unwrapBlock',\n  'unwrapInline',\n  'wrapBlock',\n  'wrapInline',\n]\n\nPROXY_TRANSFORMS.forEach(method => {\n  Changes[method] = (change, ...args) => {\n    const { value } = change\n    const { selection } = value\n    const methodAtRange = `${method}AtRange`\n    change[methodAtRange](selection, ...args)\n    if (method.match(/Backward$/)) {\n      change.collapseToStart()\n    } else if (method.match(/Forward$/)) {\n      change.collapseToEnd()\n    }\n  }\n})\n\nChanges.setBlock = (...args) => {\n  logger.deprecate(\n    'slate@0.33.0',\n    'The `setBlock` method of Slate changes has been renamed to `setBlocks`.'\n  )\n  Changes.setBlocks(...args)\n}\n\nChanges.setInline = (...args) => {\n  logger.deprecate(\n    'slate@0.33.0',\n    'The `setInline` method of Slate changes has been renamed to `setInlines`.'\n  )\n  Changes.setInlines(...args)\n}\n\n/**\n * Add a `mark` to the characters in the current selection.\n *\n * @param {Change} change\n * @param {Mark} mark\n */\n\nChanges.addMark = (change, mark) => {\n  mark = Mark.create(mark)\n  const { value } = change\n  const { document, selection } = value\n\n  if (selection.isExpanded) {\n    change.addMarkAtRange(selection, mark)\n  } else if (selection.marks) {\n    const marks = selection.marks.add(mark)\n    const sel = selection.set('marks', marks)\n    change.select(sel)\n  } else {\n    const marks = document.getActiveMarksAtRange(selection).add(mark)\n    const sel = selection.set('marks', marks)\n    change.select(sel)\n  }\n}\n\n/**\n * Add a list of `marks` to the characters in the current selection.\n *\n * @param {Change} change\n * @param {Mark} mark\n */\n\nChanges.addMarks = (change, marks) => {\n  marks.forEach(mark => change.addMark(mark))\n}\n\n/**\n * Delete at the current selection.\n *\n * @param {Change} change\n */\n\nChanges.delete = change => {\n  const { value } = change\n  const { selection } = value\n  change.deleteAtRange(selection)\n\n  // Ensure that the selection is collapsed to the start, because in certain\n  // cases when deleting across inline nodes, when splitting the inline node the\n  // end point of the selection will end up after the split point.\n  change.collapseToStart()\n}\n\n/**\n * Insert a `block` at the current selection.\n *\n * @param {Change} change\n * @param {String|Object|Block} block\n */\n\nChanges.insertBlock = (change, block) => {\n  block = Block.create(block)\n  const { value } = change\n  const { selection } = value\n  change.insertBlockAtRange(selection, block)\n\n  // If the node was successfully inserted, update the selection.\n  const node = change.value.document.getNode(block.key)\n  if (node) change.collapseToEndOf(node)\n}\n\n/**\n * Insert a `fragment` at the current selection.\n *\n * @param {Change} change\n * @param {Document} fragment\n */\n\nChanges.insertFragment = (change, fragment) => {\n  if (!fragment.nodes.size) return\n\n  let { value } = change\n  let { document, selection } = value\n  const { startText, endText, startInline } = value\n  const lastText = fragment.getLastText()\n  const lastInline = fragment.getClosestInline(lastText.key)\n  const firstChild = fragment.nodes.first()\n  const lastChild = fragment.nodes.last()\n  const keys = document.getTexts().map(text => text.key)\n  const isAppending =\n    !startInline ||\n    selection.hasEdgeAtStartOf(startText) ||\n    selection.hasEdgeAtEndOf(endText)\n\n  const isInserting =\n    fragment.hasBlocks(firstChild.key) || fragment.hasBlocks(lastChild.key)\n\n  change.insertFragmentAtRange(selection, fragment)\n  value = change.value\n  document = value.document\n\n  const newTexts = document.getTexts().filter(n => !keys.includes(n.key))\n  const newText = isAppending ? newTexts.last() : newTexts.takeLast(2).first()\n\n  if (newText && (lastInline || isInserting)) {\n    change.select(selection.collapseToEndOf(newText))\n  } else if (newText) {\n    change.select(\n      selection.collapseToStartOf(newText).move(lastText.text.length)\n    )\n  } else {\n    change.select(selection.collapseToStart().move(lastText.text.length))\n  }\n}\n\n/**\n * Insert an `inline` at the current selection.\n *\n * @param {Change} change\n * @param {String|Object|Inline} inline\n */\n\nChanges.insertInline = (change, inline) => {\n  inline = Inline.create(inline)\n  const { value } = change\n  const { selection } = value\n  change.insertInlineAtRange(selection, inline)\n\n  // If the node was successfully inserted, update the selection.\n  const node = change.value.document.getNode(inline.key)\n  if (node) change.collapseToEndOf(node)\n}\n\n/**\n * Insert a string of `text` with optional `marks` at the current selection.\n *\n * @param {Change} change\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\nChanges.insertText = (change, text, marks) => {\n  const { value } = change\n  const { document, selection } = value\n  marks = marks || selection.marks || document.getInsertMarksAtRange(selection)\n  change.insertTextAtRange(selection, text, marks)\n\n  // If the text was successfully inserted, and the selection had marks on it,\n  // unset the selection's marks.\n  if (selection.marks && document != change.value.document) {\n    change.select({ marks: null })\n  }\n}\n\n/**\n * Split the block node at the current selection, to optional `depth`.\n *\n * @param {Change} change\n * @param {Number} depth (optional)\n */\n\nChanges.splitBlock = (change, depth = 1) => {\n  const { value } = change\n  const { selection, document } = value\n  const marks = selection.marks || document.getInsertMarksAtRange(selection)\n  change.splitBlockAtRange(selection, depth).collapseToEnd()\n  if (marks && marks.size !== 0) {\n    change.select({ marks })\n  }\n}\n\n/**\n * Remove a `mark` from the characters in the current selection.\n *\n * @param {Change} change\n * @param {Mark} mark\n */\n\nChanges.removeMark = (change, mark) => {\n  mark = Mark.create(mark)\n  const { value } = change\n  const { document, selection } = value\n\n  if (selection.isExpanded) {\n    change.removeMarkAtRange(selection, mark)\n  } else if (selection.marks) {\n    const marks = selection.marks.remove(mark)\n    const sel = selection.set('marks', marks)\n    change.select(sel)\n  } else {\n    const marks = document.getActiveMarksAtRange(selection).remove(mark)\n    const sel = selection.set('marks', marks)\n    change.select(sel)\n  }\n}\n\n/**\n * Add or remove a `mark` from the characters in the current selection,\n * depending on whether it's already there.\n *\n * @param {Change} change\n * @param {Mark} mark\n */\n\nChanges.toggleMark = (change, mark) => {\n  mark = Mark.create(mark)\n  const { value } = change\n  const exists = value.activeMarks.has(mark)\n\n  if (exists) {\n    change.removeMark(mark)\n  } else {\n    change.addMark(mark)\n  }\n}\n\n/**\n * Wrap the current selection with prefix/suffix.\n *\n * @param {Change} change\n * @param {String} prefix\n * @param {String} suffix\n */\n\nChanges.wrapText = (change, prefix, suffix = prefix) => {\n  const { value } = change\n  const { selection } = value\n  change.wrapTextAtRange(selection, prefix, suffix)\n\n  // If the selection was collapsed, it will have moved the start offset too.\n  if (selection.isCollapsed) {\n    change.moveStart(0 - prefix.length)\n  }\n\n  // Adding the suffix will have pushed the end of the selection further on, so\n  // we need to move it back to account for this.\n  change.moveEnd(0 - suffix.length)\n\n  // There's a chance that the selection points moved \"through\" each other,\n  // resulting in a now-incorrect selection direction.\n  if (selection.isForward != change.value.selection.isForward) {\n    change.flip()\n  }\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Changes\n","/**\n * Dependencies.\n */\n\nimport isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport { List, Map, Record } from 'immutable'\n\nimport MODEL_TYPES, { isType } from '../constants/model-types'\nimport generateKey from '../utils/generate-key'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: new Map(),\n  key: undefined,\n  nodes: new List(),\n}\n\n/**\n * Document.\n *\n * @type {Document}\n */\n\nclass Document extends Record(DEFAULTS) {\n  /**\n   * Create a new `Document` with `attrs`.\n   *\n   * @param {Object|Array|List|Text} attrs\n   * @return {Document}\n   */\n\n  static create(attrs = {}) {\n    if (Document.isDocument(attrs)) {\n      return attrs\n    }\n\n    if (List.isList(attrs) || Array.isArray(attrs)) {\n      attrs = { nodes: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Document.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Document.create\\` only accepts objects, arrays, lists or documents, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Document` from a JSON `object`.\n   *\n   * @param {Object|Document} object\n   * @return {Document}\n   */\n\n  static fromJSON(object) {\n    if (Document.isDocument(object)) {\n      return object\n    }\n\n    const { data = {}, key = generateKey(), nodes = [] } = object\n\n    const document = new Document({\n      key,\n      data: new Map(data),\n      nodes: Document.createChildren(nodes),\n    })\n\n    return document\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Document.fromJSON\n\n  /**\n   * Check if `any` is a `Document`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isDocument = isType.bind(null, 'DOCUMENT')\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'document'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Check if the document is empty.\n   * Returns true if all it's children nodes are empty.\n   *\n   * @return {Boolean}\n   */\n\n  get isEmpty() {\n    return !this.nodes.some(child => !child.isEmpty)\n  }\n\n  /**\n   * Get the concatenated text of all the document's children.\n   *\n   * @return {String}\n   */\n\n  get text() {\n    return this.getText()\n  }\n\n  /**\n   * Return a JSON representation of the document.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      data: this.data.toJSON(),\n      nodes: this.nodes.toArray().map(n => n.toJSON(options)),\n    }\n\n    if (options.preserveKeys) {\n      object.key = this.key\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS(options) {\n    return this.toJSON(options)\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nDocument.prototype[MODEL_TYPES.DOCUMENT] = true\n\n/**\n * Export.\n *\n * @type {Document}\n */\n\nexport default Document\n","import isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport { List, Record, Set } from 'immutable'\n\nimport MODEL_TYPES from '../constants/model-types'\nimport Mark from './mark'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  anchorKey: null,\n  anchorOffset: 0,\n  focusKey: null,\n  focusOffset: 0,\n  isBackward: null,\n  isFocused: false,\n  marks: null,\n}\n\n/**\n * Range.\n *\n * @type {Range}\n */\n\nclass Range extends Record(DEFAULTS) {\n  /**\n   * Create a new `Range` with `attrs`.\n   *\n   * @param {Object|Range} attrs\n   * @return {Range}\n   */\n\n  static create(attrs = {}) {\n    if (Range.isRange(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Range.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Range.create\\` only accepts objects or ranges, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Ranges` from `elements`.\n   *\n   * @param {Array<Range|Object>|List<Range|Object>} elements\n   * @return {List<Range>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Range.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Range.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable range properties from `attrs`.\n   *\n   * @param {Object|String|Range} attrs\n   * @return {Object}\n   */\n\n  static createProperties(attrs = {}) {\n    if (Range.isRange(attrs)) {\n      return {\n        anchorKey: attrs.anchorKey,\n        anchorOffset: attrs.anchorOffset,\n        focusKey: attrs.focusKey,\n        focusOffset: attrs.focusOffset,\n        isBackward: attrs.isBackward,\n        isFocused: attrs.isFocused,\n        marks: attrs.marks,\n      }\n    }\n\n    if (isPlainObject(attrs)) {\n      const props = {}\n      if ('anchorKey' in attrs) props.anchorKey = attrs.anchorKey\n      if ('anchorOffset' in attrs) props.anchorOffset = attrs.anchorOffset\n      if ('anchorPath' in attrs) props.anchorPath = attrs.anchorPath\n      if ('focusKey' in attrs) props.focusKey = attrs.focusKey\n      if ('focusOffset' in attrs) props.focusOffset = attrs.focusOffset\n      if ('focusPath' in attrs) props.focusPath = attrs.focusPath\n      if ('isBackward' in attrs) props.isBackward = attrs.isBackward\n      if ('isFocused' in attrs) props.isFocused = attrs.isFocused\n      if ('marks' in attrs)\n        props.marks = attrs.marks == null ? null : Mark.createSet(attrs.marks)\n      return props\n    }\n\n    throw new Error(\n      `\\`Range.createProperties\\` only accepts objects or ranges, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Range` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Range}\n   */\n\n  static fromJSON(object) {\n    const {\n      anchorKey = null,\n      anchorOffset = 0,\n      focusKey = null,\n      focusOffset = 0,\n      isBackward = null,\n      isFocused = false,\n      marks = null,\n    } = object\n\n    const range = new Range({\n      anchorKey,\n      anchorOffset,\n      focusKey,\n      focusOffset,\n      isBackward,\n      isFocused,\n      marks: marks == null ? null : new Set(marks.map(Mark.fromJSON)),\n    })\n\n    return range\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Range.fromJSON\n\n  /**\n   * Check if an `obj` is a `Range`.\n   *\n   * @param {Any} obj\n   * @return {Boolean}\n   */\n\n  static isRange(obj) {\n    return !!(obj && obj[MODEL_TYPES.RANGE])\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'range'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Check whether the range is blurred.\n   *\n   * @return {Boolean}\n   */\n\n  get isBlurred() {\n    return !this.isFocused\n  }\n\n  /**\n   * Check whether the range is collapsed.\n   *\n   * @return {Boolean}\n   */\n\n  get isCollapsed() {\n    return (\n      this.anchorKey == this.focusKey && this.anchorOffset == this.focusOffset\n    )\n  }\n\n  /**\n   * Check whether the range is expanded.\n   *\n   * @return {Boolean}\n   */\n\n  get isExpanded() {\n    return !this.isCollapsed\n  }\n\n  /**\n   * Check whether the range is forward.\n   *\n   * @return {Boolean}\n   */\n\n  get isForward() {\n    return this.isBackward == null ? null : !this.isBackward\n  }\n\n  /**\n   * Check whether the range's keys are set.\n   *\n   * @return {Boolean}\n   */\n\n  get isSet() {\n    return this.anchorKey != null && this.focusKey != null\n  }\n\n  /**\n   * Check whether the range's keys are not set.\n   *\n   * @return {Boolean}\n   */\n\n  get isUnset() {\n    return !this.isSet\n  }\n\n  /**\n   * Get the start key.\n   *\n   * @return {String}\n   */\n\n  get startKey() {\n    return this.isBackward ? this.focusKey : this.anchorKey\n  }\n\n  /**\n   * Get the start offset.\n   *\n   * @return {String}\n   */\n\n  get startOffset() {\n    return this.isBackward ? this.focusOffset : this.anchorOffset\n  }\n\n  /**\n   * Get the end key.\n   *\n   * @return {String}\n   */\n\n  get endKey() {\n    return this.isBackward ? this.anchorKey : this.focusKey\n  }\n\n  /**\n   * Get the end offset.\n   *\n   * @return {String}\n   */\n\n  get endOffset() {\n    return this.isBackward ? this.anchorOffset : this.focusOffset\n  }\n\n  /**\n   * Check whether anchor point of the range is at the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  hasAnchorAtStartOf(node) {\n    // PERF: Do a check for a `0` offset first since it's quickest.\n    if (this.anchorOffset != 0) return false\n    const first = getFirst(node)\n    return this.anchorKey == first.key\n  }\n\n  /**\n   * Check whether anchor point of the range is at the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  hasAnchorAtEndOf(node) {\n    const last = getLast(node)\n    return this.anchorKey == last.key && this.anchorOffset == last.text.length\n  }\n\n  /**\n   * Check whether the anchor edge of a range is in a `node` and at an\n   * offset between `start` and `end`.\n   *\n   * @param {Node} node\n   * @param {Number} start\n   * @param {Number} end\n   * @return {Boolean}\n   */\n\n  hasAnchorBetween(node, start, end) {\n    return (\n      this.anchorOffset <= end &&\n      start <= this.anchorOffset &&\n      this.hasAnchorIn(node)\n    )\n  }\n\n  /**\n   * Check whether the anchor edge of a range is in a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  hasAnchorIn(node) {\n    return node.object == 'text'\n      ? node.key == this.anchorKey\n      : this.anchorKey != null && node.hasDescendant(this.anchorKey)\n  }\n\n  /**\n   * Check whether focus point of the range is at the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  hasFocusAtEndOf(node) {\n    const last = getLast(node)\n    return this.focusKey == last.key && this.focusOffset == last.text.length\n  }\n\n  /**\n   * Check whether focus point of the range is at the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  hasFocusAtStartOf(node) {\n    if (this.focusOffset != 0) return false\n    const first = getFirst(node)\n    return this.focusKey == first.key\n  }\n\n  /**\n   * Check whether the focus edge of a range is in a `node` and at an\n   * offset between `start` and `end`.\n   *\n   * @param {Node} node\n   * @param {Number} start\n   * @param {Number} end\n   * @return {Boolean}\n   */\n\n  hasFocusBetween(node, start, end) {\n    return (\n      start <= this.focusOffset &&\n      this.focusOffset <= end &&\n      this.hasFocusIn(node)\n    )\n  }\n\n  /**\n   * Check whether the focus edge of a range is in a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  hasFocusIn(node) {\n    return node.object == 'text'\n      ? node.key == this.focusKey\n      : this.focusKey != null && node.hasDescendant(this.focusKey)\n  }\n\n  /**\n   * Check whether the range is at the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  isAtStartOf(node) {\n    return this.isCollapsed && this.hasAnchorAtStartOf(node)\n  }\n\n  /**\n   * Check whether the range is at the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  isAtEndOf(node) {\n    return this.isCollapsed && this.hasAnchorAtEndOf(node)\n  }\n\n  /**\n   * Focus the range.\n   *\n   * @return {Range}\n   */\n\n  focus() {\n    return this.merge({\n      isFocused: true,\n    })\n  }\n\n  /**\n   * Blur the range.\n   *\n   * @return {Range}\n   */\n\n  blur() {\n    return this.merge({\n      isFocused: false,\n    })\n  }\n\n  /**\n   * Unset the range.\n   *\n   * @return {Range}\n   */\n\n  deselect() {\n    return this.merge({\n      anchorKey: null,\n      anchorOffset: 0,\n      focusKey: null,\n      focusOffset: 0,\n      isFocused: false,\n      isBackward: false,\n    })\n  }\n\n  /**\n   * Flip the range.\n   *\n   * @return {Range}\n   */\n\n  flip() {\n    return this.merge({\n      anchorKey: this.focusKey,\n      anchorOffset: this.focusOffset,\n      focusKey: this.anchorKey,\n      focusOffset: this.anchorOffset,\n      isBackward: this.isBackward == null ? null : !this.isBackward,\n    })\n  }\n\n  /**\n   * Move the anchor offset `n` characters.\n   *\n   * @param {Number} n (optional)\n   * @return {Range}\n   */\n\n  moveAnchor(n = 1) {\n    const { anchorKey, focusKey, focusOffset, isBackward } = this\n    const anchorOffset = this.anchorOffset + n\n    return this.merge({\n      anchorOffset,\n      isBackward:\n        anchorKey == focusKey ? anchorOffset > focusOffset : isBackward,\n    })\n  }\n\n  /**\n   * Move the anchor offset `n` characters.\n   *\n   * @param {Number} n (optional)\n   * @return {Range}\n   */\n\n  moveFocus(n = 1) {\n    const { anchorKey, anchorOffset, focusKey, isBackward } = this\n    const focusOffset = this.focusOffset + n\n    return this.merge({\n      focusOffset,\n      isBackward:\n        focusKey == anchorKey ? anchorOffset > focusOffset : isBackward,\n    })\n  }\n\n  /**\n   * Move the range's anchor point to a `key` and `offset`.\n   *\n   * @param {String} key\n   * @param {Number} offset\n   * @return {Range}\n   */\n\n  moveAnchorTo(key, offset) {\n    const { anchorKey, focusKey, focusOffset, isBackward } = this\n    return this.merge({\n      anchorKey: key,\n      anchorOffset: offset,\n      isBackward:\n        key == focusKey\n          ? offset > focusOffset\n          : key == anchorKey ? isBackward : null,\n    })\n  }\n\n  /**\n   * Move the range's focus point to a `key` and `offset`.\n   *\n   * @param {String} key\n   * @param {Number} offset\n   * @return {Range}\n   */\n\n  moveFocusTo(key, offset) {\n    const { focusKey, anchorKey, anchorOffset, isBackward } = this\n    return this.merge({\n      focusKey: key,\n      focusOffset: offset,\n      isBackward:\n        key == anchorKey\n          ? anchorOffset > offset\n          : key == focusKey ? isBackward : null,\n    })\n  }\n\n  /**\n   * Move the range to `anchorOffset`.\n   *\n   * @param {Number} anchorOffset\n   * @return {Range}\n   */\n\n  moveAnchorOffsetTo(anchorOffset) {\n    return this.merge({\n      anchorOffset,\n      isBackward:\n        this.anchorKey == this.focusKey\n          ? anchorOffset > this.focusOffset\n          : this.isBackward,\n    })\n  }\n\n  /**\n   * Move the range to `focusOffset`.\n   *\n   * @param {Number} focusOffset\n   * @return {Range}\n   */\n\n  moveFocusOffsetTo(focusOffset) {\n    return this.merge({\n      focusOffset,\n      isBackward:\n        this.anchorKey == this.focusKey\n          ? this.anchorOffset > focusOffset\n          : this.isBackward,\n    })\n  }\n\n  /**\n   * Move the range to `anchorOffset` and `focusOffset`.\n   *\n   * @param {Number} anchorOffset\n   * @param {Number} focusOffset (optional)\n   * @return {Range}\n   */\n\n  moveOffsetsTo(anchorOffset, focusOffset = anchorOffset) {\n    return this.moveAnchorOffsetTo(anchorOffset).moveFocusOffsetTo(focusOffset)\n  }\n\n  /**\n   * Move the focus point to the anchor point.\n   *\n   * @return {Range}\n   */\n\n  moveToAnchor() {\n    return this.moveFocusTo(this.anchorKey, this.anchorOffset)\n  }\n\n  /**\n   * Move the anchor point to the focus point.\n   *\n   * @return {Range}\n   */\n\n  moveToFocus() {\n    return this.moveAnchorTo(this.focusKey, this.focusOffset)\n  }\n\n  /**\n   * Move the range's anchor point to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveAnchorToStartOf(node) {\n    node = getFirst(node)\n    return this.moveAnchorTo(node.key, 0)\n  }\n\n  /**\n   * Move the range's anchor point to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveAnchorToEndOf(node) {\n    node = getLast(node)\n    return this.moveAnchorTo(node.key, node.text.length)\n  }\n\n  /**\n   * Move the range's focus point to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveFocusToStartOf(node) {\n    node = getFirst(node)\n    return this.moveFocusTo(node.key, 0)\n  }\n\n  /**\n   * Move the range's focus point to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveFocusToEndOf(node) {\n    node = getLast(node)\n    return this.moveFocusTo(node.key, node.text.length)\n  }\n\n  /**\n   * Move to the entire range of `start` and `end` nodes.\n   *\n   * @param {Node} start\n   * @param {Node} end (optional)\n   * @return {Range}\n   */\n\n  moveToRangeOf(start, end = start) {\n    const range = this.isBackward ? this.flip() : this\n    return range.moveAnchorToStartOf(start).moveFocusToEndOf(end)\n  }\n\n  /**\n   * Normalize the range, relative to a `node`, ensuring that the anchor\n   * and focus nodes of the range always refer to leaf text nodes.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  normalize(node) {\n    const range = this\n    let { anchorKey, anchorOffset, focusKey, focusOffset, isBackward } = range\n\n    const anchorOffsetType = typeof anchorOffset\n    const focusOffsetType = typeof focusOffset\n    if (anchorOffsetType != 'number' || focusOffsetType != 'number') {\n      logger.warn(\n        `The range offsets should be numbers, but they were of type \"${anchorOffsetType}\" and \"${focusOffsetType}\".`\n      )\n    }\n\n    // If the range is unset, make sure it is properly zeroed out.\n    if (anchorKey == null || focusKey == null) {\n      return range.merge({\n        anchorKey: null,\n        anchorOffset: 0,\n        focusKey: null,\n        focusOffset: 0,\n        isBackward: false,\n      })\n    }\n\n    // Get the anchor and focus nodes.\n    let anchorNode = node.getDescendant(anchorKey)\n    let focusNode = node.getDescendant(focusKey)\n\n    // If the range is malformed, warn and zero it out.\n    if (!anchorNode || !focusNode) {\n      logger.warn(\n        'The range was invalid and was reset. The range in question was:',\n        range\n      )\n      const first = node.getFirstText()\n      return range.merge({\n        anchorKey: first ? first.key : null,\n        anchorOffset: 0,\n        focusKey: first ? first.key : null,\n        focusOffset: 0,\n        isBackward: false,\n      })\n    }\n\n    // If the anchor node isn't a text node, match it to one.\n    if (anchorNode.object != 'text') {\n      logger.warn(\n        'The range anchor was set to a Node that is not a Text node. This should not happen and can degrade performance. The node in question was:',\n        anchorNode\n      )\n      const anchorText = anchorNode.getTextAtOffset(anchorOffset)\n      const offset = anchorNode.getOffset(anchorText.key)\n      anchorOffset = anchorOffset - offset\n      anchorNode = anchorText\n    }\n\n    // If the focus node isn't a text node, match it to one.\n    if (focusNode.object != 'text') {\n      logger.warn(\n        'The range focus was set to a Node that is not a Text node. This should not happen and can degrade performance. The node in question was:',\n        focusNode\n      )\n      const focusText = focusNode.getTextAtOffset(focusOffset)\n      const offset = focusNode.getOffset(focusText.key)\n      focusOffset = focusOffset - offset\n      focusNode = focusText\n    }\n\n    // If `isBackward` is not set, derive it.\n    if (isBackward == null) {\n      if (anchorNode.key === focusNode.key) {\n        isBackward = anchorOffset > focusOffset\n      } else {\n        isBackward = !node.areDescendantsSorted(anchorNode.key, focusNode.key)\n      }\n    }\n\n    // Merge in any updated properties.\n    return range.merge({\n      anchorKey: anchorNode.key,\n      anchorOffset,\n      focusKey: focusNode.key,\n      focusOffset,\n      isBackward,\n    })\n  }\n\n  /**\n   * Return a JSON representation of the range.\n   *\n   * @return {Object}\n   */\n\n  toJSON() {\n    const object = {\n      object: this.object,\n      anchorKey: this.anchorKey,\n      anchorOffset: this.anchorOffset,\n      focusKey: this.focusKey,\n      focusOffset: this.focusOffset,\n      isBackward: this.isBackward,\n      isFocused: this.isFocused,\n      marks:\n        this.marks == null ? null : this.marks.toArray().map(m => m.toJSON()),\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS() {\n    return this.toJSON()\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nRange.prototype[MODEL_TYPES.RANGE] = true\n\n/**\n * Mix in some \"move\" convenience methods.\n */\n\nconst MOVE_METHODS = [\n  ['move', ''],\n  ['move', 'To'],\n  ['move', 'ToStartOf'],\n  ['move', 'ToEndOf'],\n]\n\nMOVE_METHODS.forEach(([p, s]) => {\n  Range.prototype[`${p}${s}`] = function(...args) {\n    return this[`${p}Anchor${s}`](...args)[`${p}Focus${s}`](...args)\n  }\n})\n\n/**\n * Mix in the \"start\", \"end\" and \"edge\" convenience methods.\n */\n\nconst EDGE_METHODS = [\n  ['has', 'AtStartOf', true],\n  ['has', 'AtEndOf', true],\n  ['has', 'Between', true],\n  ['has', 'In', true],\n  ['collapseTo', ''],\n  ['move', ''],\n  ['moveTo', ''],\n  ['move', 'To'],\n  ['move', 'OffsetTo'],\n]\n\nEDGE_METHODS.forEach(([p, s, hasEdge]) => {\n  const anchor = `${p}Anchor${s}`\n  const focus = `${p}Focus${s}`\n\n  Range.prototype[`${p}Start${s}`] = function(...args) {\n    return this.isBackward ? this[focus](...args) : this[anchor](...args)\n  }\n\n  Range.prototype[`${p}End${s}`] = function(...args) {\n    return this.isBackward ? this[anchor](...args) : this[focus](...args)\n  }\n\n  if (hasEdge) {\n    Range.prototype[`${p}Edge${s}`] = function(...args) {\n      return this[anchor](...args) || this[focus](...args)\n    }\n  }\n})\n\n/**\n * Mix in some aliases for convenience / parallelism with the browser APIs.\n */\n\nconst ALIAS_METHODS = [\n  ['collapseTo', 'moveTo'],\n  ['collapseToAnchor', 'moveToAnchor'],\n  ['collapseToFocus', 'moveToFocus'],\n  ['collapseToStart', 'moveToStart'],\n  ['collapseToEnd', 'moveToEnd'],\n  ['collapseToStartOf', 'moveToStartOf'],\n  ['collapseToEndOf', 'moveToEndOf'],\n  ['extend', 'moveFocus'],\n  ['extendTo', 'moveFocusTo'],\n  ['extendToStartOf', 'moveFocusToStartOf'],\n  ['extendToEndOf', 'moveFocusToEndOf'],\n]\n\nALIAS_METHODS.forEach(([alias, method]) => {\n  Range.prototype[alias] = function(...args) {\n    return this[method](...args)\n  }\n})\n\n/**\n * Get the first text of a `node`.\n *\n * @param {Node} node\n * @return {Text}\n */\n\nfunction getFirst(node) {\n  return node.object == 'text' ? node : node.getFirstText()\n}\n\n/**\n * Get the last text of a `node`.\n *\n * @param {Node} node\n * @return {Text}\n */\n\nfunction getLast(node) {\n  return node.object == 'text' ? node : node.getLastText()\n}\n\n/**\n * Export.\n *\n * @type {Range}\n */\n\nexport default Range\n","import isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport { List, Record, Set } from 'immutable'\n\nimport MODEL_TYPES, { isType } from '../constants/model-types'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  marks: new Set(),\n  text: '',\n}\n\n/**\n * Character.\n *\n * @type {Character}\n */\n\nclass Character extends Record(DEFAULTS) {\n  /**\n   * Create a `Character` with `attrs`.\n   *\n   * @param {Object|String|Character} attrs\n   * @return {Character}\n   */\n\n  static create(attrs = {}) {\n    if (Character.isCharacter(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs == 'string') {\n      attrs = { text: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Character.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Character.create\\` only accepts objects, strings or characters, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Characters` from `elements`.\n   *\n   * @param {String|Array<Object|Character|String>|List<Object|Character|String>} elements\n   * @return {List<Character>}\n   */\n\n  static createList(elements = []) {\n    if (typeof elements == 'string') {\n      elements = elements.split('')\n    }\n\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Character.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Block.createList\\` only accepts strings, arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a `Character` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Character}\n   */\n\n  static fromJSON(object) {\n    const { text, marks = [] } = object\n\n    if (typeof text != 'string') {\n      throw new Error('`Character.fromJSON` requires a block `text` string.')\n    }\n\n    const character = new Character({\n      text,\n      marks: new Set(marks),\n    })\n\n    return character\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Character.fromJSON\n\n  /**\n   * Check if `any` is a `Character`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isCharacter = isType.bind(null, 'CHARACTER')\n\n  /**\n   * Check if `any` is a character list.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isCharacterList(any) {\n    return List.isList(any) && any.every(item => Character.isCharacter(item))\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'character'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Return a JSON representation of the character.\n   *\n   * @return {Object}\n   */\n\n  toJSON() {\n    const object = {\n      object: this.object,\n      text: this.text,\n      marks: this.marks.toArray().map(m => m.toJSON()),\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS() {\n    return this.toJSON()\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nCharacter.prototype[MODEL_TYPES.CHARACTER] = true\n\n/**\n * Export.\n *\n * @type {Character}\n */\n\nexport default Character\n","import isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport { List, Record, Set } from 'immutable'\n\nimport MODEL_TYPES, { isType } from '../constants/model-types'\nimport Character from './character'\nimport Mark from './mark'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  marks: new Set(),\n  text: '',\n}\n\n/**\n * Leaf.\n *\n * @type {Leaf}\n */\n\nclass Leaf extends Record(DEFAULTS) {\n  /**\n   * Create a new `Leaf` with `attrs`.\n   *\n   * @param {Object|Leaf} attrs\n   * @return {Leaf}\n   */\n\n  static create(attrs = {}) {\n    if (Leaf.isLeaf(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs == 'string') {\n      attrs = { text: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Leaf.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Leaf.create\\` only accepts objects, strings or leaves, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Leaf` list from `attrs`.\n   *\n   * @param {Array<Leaf|Object>|List<Leaf|Object>} attrs\n   * @return {List<Leaf>}\n   */\n\n  static createList(attrs = []) {\n    if (List.isList(attrs) || Array.isArray(attrs)) {\n      const list = new List(attrs.map(Leaf.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Leaf.createList\\` only accepts arrays or lists, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Leaf` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Leaf}\n   */\n\n  static fromJSON(object) {\n    const { text = '', marks = [] } = object\n\n    const leaf = new Leaf({\n      text,\n      marks: new Set(marks.map(Mark.fromJSON)),\n    })\n\n    return leaf\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Leaf.fromJSON\n\n  /**\n   * Check if `any` is a `Leaf`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isLeaf = isType.bind(null, 'LEAF')\n\n  /**\n   * Check if `any` is a list of leaves.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isLeafList(any) {\n    return List.isList(any) && any.every(item => Leaf.isLeaf(item))\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'leaf'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Return leaf as a list of characters\n   *\n   * @return {List<Character>}\n   */\n\n  getCharacters() {\n    const { marks } = this\n    const characters = Character.createList(\n      this.text.split('').map(char => {\n        return Character.create({\n          text: char,\n          marks,\n        })\n      })\n    )\n\n    return characters\n  }\n\n  /**\n   * Return a JSON representation of the leaf.\n   *\n   * @return {Object}\n   */\n\n  toJSON() {\n    const object = {\n      object: this.object,\n      text: this.text,\n      marks: this.marks.toArray().map(m => m.toJSON()),\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS() {\n    return this.toJSON()\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nLeaf.prototype[MODEL_TYPES.LEAF] = true\n\n/**\n * Export.\n *\n * @type {Leaf}\n */\n\nexport default Leaf\n","import isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport { List, OrderedSet, Record, Set, is } from 'immutable'\n\nimport Character from './character'\nimport Mark from './mark'\nimport Leaf from './leaf'\nimport MODEL_TYPES, { isType } from '../constants/model-types'\nimport generateKey from '../utils/generate-key'\nimport memoize from '../utils/memoize'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  characters: new List(),\n  key: undefined,\n}\n\n/**\n * Text.\n *\n * @type {Text}\n */\n\nclass Text extends Record(DEFAULTS) {\n  /**\n   * Create a new `Text` with `attrs`.\n   *\n   * @param {Object|Array|List|String|Text} attrs\n   * @return {Text}\n   */\n\n  static create(attrs = '') {\n    if (Text.isText(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs == 'string') {\n      attrs = { leaves: [{ text: attrs }] }\n    }\n\n    if (isPlainObject(attrs)) {\n      if (attrs.text) {\n        const { text, marks, key } = attrs\n        attrs = { key, leaves: [{ text, marks }] }\n      }\n\n      return Text.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Text.create\\` only accepts objects, arrays, strings or texts, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Texts` from `elements`.\n   *\n   * @param {Array<Text|Object>|List<Text|Object>} elements\n   * @return {List<Text>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Text.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Text.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a `Text` from a JSON `object`.\n   *\n   * @param {Object|Text} object\n   * @return {Text}\n   */\n\n  static fromJSON(object) {\n    if (Text.isText(object)) {\n      return object\n    }\n\n    const { leaves = [], key = generateKey() } = object\n\n    const characters = leaves\n      .map(Leaf.fromJSON)\n      .reduce((l, r) => l.concat(r.getCharacters()), new List())\n\n    const node = new Text({\n      characters,\n      key,\n    })\n\n    return node\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Text.fromJSON\n\n  /**\n   * Check if `any` is a `Text`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isText = isType.bind(null, 'TEXT')\n\n  /**\n   * Check if `any` is a listof texts.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isTextList(any) {\n    return List.isList(any) && any.every(item => Text.isText(item))\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'text'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Is the node empty?\n   *\n   * @return {Boolean}\n   */\n\n  get isEmpty() {\n    return this.text == ''\n  }\n\n  /**\n   * Get the concatenated text of the node.\n   *\n   * @return {String}\n   */\n\n  get text() {\n    return this.characters.reduce((string, char) => string + char.text, '')\n  }\n\n  /**\n   * Add a `mark` at `index` and `length`.\n   *\n   * @param {Number} index\n   * @param {Number} length\n   * @param {Mark} mark\n   * @return {Text}\n   */\n\n  addMark(index, length, mark) {\n    const marks = new Set([mark])\n    return this.addMarks(index, length, marks)\n  }\n\n  /**\n   * Add a `set` of marks at `index` and `length`.\n   *\n   * @param {Number} index\n   * @param {Number} length\n   * @param {Set<Mark>} set\n   * @return {Text}\n   */\n\n  addMarks(index, length, set) {\n    const characters = this.characters.map((char, i) => {\n      if (i < index) return char\n      if (i >= index + length) return char\n      let { marks } = char\n      marks = marks.union(set)\n      char = char.set('marks', marks)\n      return char\n    })\n\n    return this.set('characters', characters)\n  }\n\n  /**\n   * Derive a set of decorated characters with `decorations`.\n   *\n   * @param {List<Decoration>} decorations\n   * @return {List<Character>}\n   */\n\n  getDecoratedCharacters(decorations) {\n    let node = this\n    const { key, characters } = node\n\n    // PERF: Exit early if there are no characters to be decorated.\n    if (characters.size == 0) return characters\n\n    decorations.forEach(range => {\n      const { startKey, endKey, startOffset, endOffset, marks } = range\n      const hasStart = startKey == key\n      const hasEnd = endKey == key\n      const index = hasStart ? startOffset : 0\n      const length = hasEnd ? endOffset - index : characters.size\n      node = node.addMarks(index, length, marks)\n    })\n\n    return node.characters\n  }\n\n  /**\n   * Get the decorations for the node from a `schema`.\n   *\n   * @param {Schema} schema\n   * @return {Array}\n   */\n\n  getDecorations(schema) {\n    return schema.__getDecorations(this)\n  }\n\n  /**\n   * Derive the leaves for a list of `characters`.\n   *\n   * @param {Array|Void} decorations (optional)\n   * @return {List<Leaf>}\n   */\n\n  getLeaves(decorations = []) {\n    const characters = this.getDecoratedCharacters(decorations)\n    let leaves = []\n\n    // PERF: cache previous values for faster lookup.\n    let prevChar\n    let prevLeaf\n\n    // If there are no characters, return one empty range.\n    if (characters.size == 0) {\n      leaves.push({})\n    } else {\n      // Otherwise, loop the characters and build the leaves...\n      characters.forEach((char, i) => {\n        const { marks, text } = char\n\n        // The first one can always just be created.\n        if (i == 0) {\n          prevChar = char\n          prevLeaf = { text, marks }\n          leaves.push(prevLeaf)\n          return\n        }\n\n        // Otherwise, compare the current and previous marks.\n        const prevMarks = prevChar.marks\n        const isSame = is(marks, prevMarks)\n\n        // If the marks are the same, add the text to the previous range.\n        if (isSame) {\n          prevChar = char\n          prevLeaf.text += text\n          return\n        }\n\n        // Otherwise, create a new range.\n        prevChar = char\n        prevLeaf = { text, marks }\n        leaves.push(prevLeaf)\n      }, [])\n    }\n\n    // PERF: convert the leaves to immutable objects after iterating.\n    leaves = new List(leaves.map(object => new Leaf(object)))\n\n    // Return the leaves.\n    return leaves\n  }\n\n  /**\n   * Get all of the active marks on between two offsets\n   *\n   * @return {Set<Mark>}\n   */\n\n  getActiveMarksBetweenOffsets(startOffset, endOffset) {\n    if (startOffset === 0 && endOffset === this.characters.size) {\n      return this.getActiveMarks()\n    }\n    const startCharacter = this.characters.get(startOffset)\n    if (!startCharacter) return Set()\n    const result = startCharacter.marks\n    if (result.size === 0) return result\n    return result.withMutations(x => {\n      for (let index = startOffset + 1; index < endOffset; index++) {\n        const c = this.characters.get(index)\n        x.intersect(c.marks)\n        if (x.size === 0) return\n      }\n    })\n  }\n\n  /**\n   * Get all of the active marks on the text\n   *\n   * @return {Set<Mark>}\n   */\n\n  getActiveMarks() {\n    if (this.characters.size === 0) return Set()\n    const result = this.characters.first().marks\n    if (result.size === 0) return result\n\n    return result.withMutations(x => {\n      this.characters.forEach(c => {\n        x.intersect(c.marks)\n        if (x.size === 0) return false\n      })\n    })\n  }\n\n  /**\n   * Get all of the marks on between two offsets\n   *\n   * @return {OrderedSet<Mark>}\n   */\n\n  getMarksBetweenOffsets(startOffset, endOffset) {\n    if (startOffset === 0 && endOffset === this.characters.size) {\n      return this.getMarks()\n    }\n    return new OrderedSet().withMutations(result => {\n      for (let index = startOffset; index < endOffset; index++) {\n        const c = this.characters.get(index)\n        result.union(c.marks)\n      }\n    })\n  }\n\n  /**\n   * Get all of the marks on the text.\n   *\n   * @return {OrderedSet<Mark>}\n   */\n\n  getMarks() {\n    const array = this.getMarksAsArray()\n    return new OrderedSet(array)\n  }\n\n  /**\n   * Get all of the marks on the text as an array\n   *\n   * @return {Array}\n   */\n\n  getMarksAsArray() {\n    if (this.characters.size === 0) return []\n    const first = this.characters.first().marks\n    let previousMark = first\n    const result = []\n    this.characters.forEach(c => {\n      // If the character marks is the same with the\n      // previous characters, we do not need to\n      // add the marks twice\n      if (c.marks === previousMark) return true\n      previousMark = c.marks\n      result.push(previousMark.toArray())\n    })\n    return Array.prototype.concat.apply(first.toArray(), result)\n  }\n\n  /**\n   * Get the marks on the text at `index`.\n   *\n   * @param {Number} index\n   * @return {Set<Mark>}\n   */\n\n  getMarksAtIndex(index) {\n    if (index == 0) return Mark.createSet()\n    const { characters } = this\n    const char = characters.get(index - 1)\n    if (!char) return Mark.createSet()\n    return char.marks\n  }\n\n  /**\n   * Get a node by `key`, to parallel other nodes.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getNode(key) {\n    return this.key == key ? this : null\n  }\n\n  /**\n   * Check if the node has a node by `key`, to parallel other nodes.\n   *\n   * @param {String} key\n   * @return {Boolean}\n   */\n\n  hasNode(key) {\n    return !!this.getNode(key)\n  }\n\n  /**\n   * Insert `text` at `index`.\n   *\n   * @param {Numbder} index\n   * @param {String} text\n   * @param {String} marks (optional)\n   * @return {Text}\n   */\n\n  insertText(index, text, marks) {\n    let { characters } = this\n    const chars = Character.createList(\n      text.split('').map(char => ({ text: char, marks }))\n    )\n\n    characters = characters\n      .slice(0, index)\n      .concat(chars)\n      .concat(characters.slice(index))\n\n    return this.set('characters', characters)\n  }\n\n  /**\n   * Regenerate the node's key.\n   *\n   * @return {Text}\n   */\n\n  regenerateKey() {\n    const key = generateKey()\n    return this.set('key', key)\n  }\n\n  /**\n   * Remove a `mark` at `index` and `length`.\n   *\n   * @param {Number} index\n   * @param {Number} length\n   * @param {Mark} mark\n   * @return {Text}\n   */\n\n  removeMark(index, length, mark) {\n    const characters = this.characters.map((char, i) => {\n      if (i < index) return char\n      if (i >= index + length) return char\n      let { marks } = char\n      marks = marks.remove(mark)\n      char = char.set('marks', marks)\n      return char\n    })\n\n    return this.set('characters', characters)\n  }\n\n  /**\n   * Remove text from the text node at `index` for `length`.\n   *\n   * @param {Number} index\n   * @param {Number} length\n   * @return {Text}\n   */\n\n  removeText(index, length) {\n    let { characters } = this\n    const start = index\n    const end = index + length\n    characters = characters.filterNot((char, i) => start <= i && i < end)\n    return this.set('characters', characters)\n  }\n\n  /**\n   * Return a JSON representation of the text.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      leaves: this.getLeaves()\n        .toArray()\n        .map(r => r.toJSON()),\n    }\n\n    if (options.preserveKeys) {\n      object.key = this.key\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS(options) {\n    return this.toJSON(options)\n  }\n\n  /**\n   * Update a `mark` at `index` and `length` with `properties`.\n   *\n   * @param {Number} index\n   * @param {Number} length\n   * @param {Mark} mark\n   * @param {Object} properties\n   * @return {Text}\n   */\n\n  updateMark(index, length, mark, properties) {\n    const newMark = mark.merge(properties)\n\n    const characters = this.characters.map((char, i) => {\n      if (i < index) return char\n      if (i >= index + length) return char\n      let { marks } = char\n      if (!marks.has(mark)) return char\n      marks = marks.remove(mark)\n      marks = marks.add(newMark)\n      char = char.set('marks', marks)\n      return char\n    })\n\n    return this.set('characters', characters)\n  }\n\n  /**\n   * Validate the text node against a `schema`.\n   *\n   * @param {Schema} schema\n   * @return {Object|Void}\n   */\n\n  validate(schema) {\n    return schema.validateNode(this)\n  }\n\n  /**\n   * Get the first invalid descendant\n   * PREF: Do not cache this method; because it can cause cycle reference\n   *\n   * @param {Schema} schema\n   * @returns {Text|Null}\n   */\n\n  getFirstInvalidDescendant(schema) {\n    return this.validate(schema) ? this : null\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nText.prototype[MODEL_TYPES.TEXT] = true\n\n/**\n * Memoize read methods.\n */\n\nmemoize(Text.prototype, [\n  'getDecoratedCharacters',\n  'getDecorations',\n  'getLeaves',\n  'getActiveMarks',\n  'getMarks',\n  'getMarksAsArray',\n  'getMarksAtIndex',\n  'validate',\n])\n\n/**\n * Export.\n *\n * @type {Text}\n */\n\nexport default Text\n","import direction from 'direction'\nimport isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport { List, OrderedSet, Set } from 'immutable'\n\nimport Data from './data'\nimport Block from './block'\nimport Inline from './inline'\nimport Document from './document'\nimport { isType } from '../constants/model-types'\nimport Range from './range'\nimport Text from './text'\nimport generateKey from '../utils/generate-key'\nimport memoize from '../utils/memoize'\n\n/**\n * Node.\n *\n * And interface that `Document`, `Block` and `Inline` all implement, to make\n * working with the recursive node tree easier.\n *\n * @type {Node}\n */\n\nclass Node {\n  /**\n   * Create a new `Node` with `attrs`.\n   *\n   * @param {Object|Node} attrs\n   * @return {Node}\n   */\n\n  static create(attrs = {}) {\n    if (Node.isNode(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      let { object } = attrs\n\n      if (!object && attrs.kind) {\n        logger.deprecate(\n          'slate@0.32.0',\n          'The `kind` property of Slate objects has been renamed to `object`.'\n        )\n        object = attrs.kind\n      }\n\n      switch (object) {\n        case 'block':\n          return Block.create(attrs)\n        case 'document':\n          return Document.create(attrs)\n        case 'inline':\n          return Inline.create(attrs)\n        case 'text':\n          return Text.create(attrs)\n        default: {\n          throw new Error('`Node.create` requires a `object` string.')\n        }\n      }\n    }\n\n    throw new Error(\n      `\\`Node.create\\` only accepts objects or nodes but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Nodes` from an array.\n   *\n   * @param {Array<Object|Node>} elements\n   * @return {List<Node>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = List(elements.map(Node.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Node.createList\\` only accepts lists or arrays, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable node properties from `attrs`.\n   *\n   * @param {Object|String|Node} attrs\n   * @return {Object}\n   */\n\n  static createProperties(attrs = {}) {\n    if (Block.isBlock(attrs) || Inline.isInline(attrs)) {\n      return {\n        data: attrs.data,\n        isVoid: attrs.isVoid,\n        type: attrs.type,\n      }\n    }\n\n    if (typeof attrs == 'string') {\n      return { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      const props = {}\n      if ('type' in attrs) props.type = attrs.type\n      if ('data' in attrs) props.data = Data.create(attrs.data)\n      if ('isVoid' in attrs) props.isVoid = attrs.isVoid\n      return props\n    }\n\n    throw new Error(\n      `\\`Node.createProperties\\` only accepts objects, strings, blocks or inlines, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Node` from a JSON `value`.\n   *\n   * @param {Object} value\n   * @return {Node}\n   */\n\n  static fromJSON(value) {\n    let { object } = value\n\n    if (!object && value.kind) {\n      logger.deprecate(\n        'slate@0.32.0',\n        'The `kind` property of Slate objects has been renamed to `object`.'\n      )\n      object = value.kind\n    }\n\n    switch (object) {\n      case 'block':\n        return Block.fromJSON(value)\n      case 'document':\n        return Document.fromJSON(value)\n      case 'inline':\n        return Inline.fromJSON(value)\n      case 'text':\n        return Text.fromJSON(value)\n      default: {\n        throw new Error(\n          `\\`Node.fromJSON\\` requires an \\`object\\` of either 'block', 'document', 'inline' or 'text', but you passed: ${value}`\n        )\n      }\n    }\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Node.fromJSON\n\n  /**\n   * Check if `any` is a `Node`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isNode(any) {\n    return !!['BLOCK', 'DOCUMENT', 'INLINE', 'TEXT'].find(type =>\n      isType(type, any)\n    )\n  }\n\n  /**\n   * Check if `any` is a list of nodes.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isNodeList(any) {\n    return List.isList(any) && any.every(item => Node.isNode(item))\n  }\n\n  /**\n   * True if the node has both descendants in that order, false otherwise. The\n   * order is depth-first, post-order.\n   *\n   * @param {String} first\n   * @param {String} second\n   * @return {Boolean}\n   */\n\n  areDescendantsSorted(first, second) {\n    first = assertKey(first)\n    second = assertKey(second)\n\n    const keys = this.getKeysAsArray()\n    const firstIndex = keys.indexOf(first)\n    const secondIndex = keys.indexOf(second)\n    if (firstIndex == -1 || secondIndex == -1) return null\n\n    return firstIndex < secondIndex\n  }\n\n  /**\n   * Assert that a node has a child by `key` and return it.\n   *\n   * @param {String} key\n   * @return {Node}\n   */\n\n  assertChild(key) {\n    const child = this.getChild(key)\n\n    if (!child) {\n      key = assertKey(key)\n      throw new Error(`Could not find a child node with key \"${key}\".`)\n    }\n\n    return child\n  }\n\n  /**\n   * Assert that a node has a descendant by `key` and return it.\n   *\n   * @param {String} key\n   * @return {Node}\n   */\n\n  assertDescendant(key) {\n    const descendant = this.getDescendant(key)\n\n    if (!descendant) {\n      key = assertKey(key)\n      throw new Error(`Could not find a descendant node with key \"${key}\".`)\n    }\n\n    return descendant\n  }\n\n  /**\n   * Assert that a node's tree has a node by `key` and return it.\n   *\n   * @param {String} key\n   * @return {Node}\n   */\n\n  assertNode(key) {\n    const node = this.getNode(key)\n\n    if (!node) {\n      key = assertKey(key)\n      throw new Error(`Could not find a node with key \"${key}\".`)\n    }\n\n    return node\n  }\n\n  /**\n   * Assert that a node exists at `path` and return it.\n   *\n   * @param {Array} path\n   * @return {Node}\n   */\n\n  assertPath(path) {\n    const descendant = this.getDescendantAtPath(path)\n\n    if (!descendant) {\n      throw new Error(`Could not find a descendant at path \"${path}\".`)\n    }\n\n    return descendant\n  }\n\n  /**\n   * Recursively filter all descendant nodes with `iterator`.\n   *\n   * @param {Function} iterator\n   * @return {List<Node>}\n   */\n\n  filterDescendants(iterator) {\n    const matches = []\n\n    this.forEachDescendant((node, i, nodes) => {\n      if (iterator(node, i, nodes)) matches.push(node)\n    })\n\n    return List(matches)\n  }\n\n  /**\n   * Recursively find all descendant nodes by `iterator`.\n   *\n   * @param {Function} iterator\n   * @return {Node|Null}\n   */\n\n  findDescendant(iterator) {\n    let found = null\n\n    this.forEachDescendant((node, i, nodes) => {\n      if (iterator(node, i, nodes)) {\n        found = node\n        return false\n      }\n    })\n\n    return found\n  }\n\n  /**\n   * Recursively iterate over all descendant nodes with `iterator`. If the\n   * iterator returns false it will break the loop.\n   *\n   * @param {Function} iterator\n   */\n\n  forEachDescendant(iterator) {\n    let ret\n\n    this.nodes.forEach((child, i, nodes) => {\n      if (iterator(child, i, nodes) === false) {\n        ret = false\n        return false\n      }\n\n      if (child.object != 'text') {\n        ret = child.forEachDescendant(iterator)\n        return ret\n      }\n    })\n\n    return ret\n  }\n\n  /**\n   * Get the path of ancestors of a descendant node by `key`.\n   *\n   * @param {String|Node} key\n   * @return {List<Node>|Null}\n   */\n\n  getAncestors(key) {\n    key = assertKey(key)\n\n    if (key == this.key) return List()\n    if (this.hasChild(key)) return List([this])\n\n    let ancestors\n    this.nodes.find(node => {\n      if (node.object == 'text') return false\n      ancestors = node.getAncestors(key)\n      return ancestors\n    })\n\n    if (ancestors) {\n      return ancestors.unshift(this)\n    } else {\n      return null\n    }\n  }\n\n  /**\n   * Get the leaf block descendants of the node.\n   *\n   * @return {List<Node>}\n   */\n\n  getBlocks() {\n    const array = this.getBlocksAsArray()\n    return new List(array)\n  }\n\n  /**\n   * Get the leaf block descendants of the node.\n   *\n   * @return {List<Node>}\n   */\n\n  getBlocksAsArray() {\n    return this.nodes.reduce((array, child) => {\n      if (child.object != 'block') return array\n      if (!child.isLeafBlock()) return array.concat(child.getBlocksAsArray())\n      array.push(child)\n      return array\n    }, [])\n  }\n\n  /**\n   * Get the leaf block descendants in a `range`.\n   *\n   * @param {Range} range\n   * @return {List<Node>}\n   */\n\n  getBlocksAtRange(range) {\n    const array = this.getBlocksAtRangeAsArray(range)\n    // Eliminate duplicates by converting to an `OrderedSet` first.\n    return new List(new OrderedSet(array))\n  }\n\n  /**\n   * Get the leaf block descendants in a `range` as an array\n   *\n   * @param {Range} range\n   * @return {Array}\n   */\n\n  getBlocksAtRangeAsArray(range) {\n    range = range.normalize(this)\n    if (range.isUnset) return []\n\n    const { startKey, endKey } = range\n    const startBlock = this.getClosestBlock(startKey)\n\n    // PERF: the most common case is when the range is in a single block node,\n    // where we can avoid a lot of iterating of the tree.\n    if (startKey == endKey) return [startBlock]\n\n    const endBlock = this.getClosestBlock(endKey)\n    const blocks = this.getBlocksAsArray()\n    const start = blocks.indexOf(startBlock)\n    const end = blocks.indexOf(endBlock)\n    return blocks.slice(start, end + 1)\n  }\n\n  /**\n   * Get all of the leaf blocks that match a `type`.\n   *\n   * @param {String} type\n   * @return {List<Node>}\n   */\n\n  getBlocksByType(type) {\n    const array = this.getBlocksByTypeAsArray(type)\n    return new List(array)\n  }\n\n  /**\n   * Get all of the leaf blocks that match a `type` as an array\n   *\n   * @param {String} type\n   * @return {Array}\n   */\n\n  getBlocksByTypeAsArray(type) {\n    return this.nodes.reduce((array, node) => {\n      if (node.object != 'block') {\n        return array\n      } else if (node.isLeafBlock() && node.type == type) {\n        array.push(node)\n        return array\n      } else {\n        return array.concat(node.getBlocksByTypeAsArray(type))\n      }\n    }, [])\n  }\n\n  /**\n   * Get all of the characters for every text node.\n   *\n   * @return {List<Character>}\n   */\n\n  getCharacters() {\n    return this.getTexts().flatMap(t => t.characters)\n  }\n\n  /**\n   * Get a list of the characters in a `range`.\n   *\n   * @param {Range} range\n   * @return {List<Character>}\n   */\n\n  getCharactersAtRange(range) {\n    range = range.normalize(this)\n    if (range.isUnset) return List()\n    const { startKey, endKey, startOffset, endOffset } = range\n    if (startKey === endKey) {\n      const endText = this.getDescendant(endKey)\n      return endText.characters.slice(startOffset, endOffset)\n    }\n\n    return this.getTextsAtRange(range).flatMap(t => {\n      if (t.key === startKey) {\n        return t.characters.slice(startOffset)\n      }\n      if (t.key === endKey) {\n        return t.characters.slice(0, endOffset)\n      }\n      return t.characters\n    })\n  }\n\n  /**\n   * Get a child node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getChild(key) {\n    key = assertKey(key)\n    return this.nodes.find(node => node.key == key)\n  }\n\n  /**\n   * Get closest parent of node by `key` that matches `iterator`.\n   *\n   * @param {String} key\n   * @param {Function} iterator\n   * @return {Node|Null}\n   */\n\n  getClosest(key, iterator) {\n    key = assertKey(key)\n    const ancestors = this.getAncestors(key)\n    if (!ancestors) {\n      throw new Error(`Could not find a descendant node with key \"${key}\".`)\n    }\n\n    // Exclude this node itself.\n    return ancestors.rest().findLast(iterator)\n  }\n\n  /**\n   * Get the closest block parent of a `node`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getClosestBlock(key) {\n    return this.getClosest(key, parent => parent.object == 'block')\n  }\n\n  /**\n   * Get the closest inline parent of a `node`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getClosestInline(key) {\n    return this.getClosest(key, parent => parent.object == 'inline')\n  }\n\n  /**\n   * Get the closest void parent of a `node`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getClosestVoid(key) {\n    return this.getClosest(key, parent => parent.isVoid)\n  }\n\n  /**\n   * Get the common ancestor of nodes `one` and `two` by keys.\n   *\n   * @param {String} one\n   * @param {String} two\n   * @return {Node}\n   */\n\n  getCommonAncestor(one, two) {\n    one = assertKey(one)\n    two = assertKey(two)\n\n    if (one == this.key) return this\n    if (two == this.key) return this\n\n    this.assertDescendant(one)\n    this.assertDescendant(two)\n    let ancestors = new List()\n    let oneParent = this.getParent(one)\n    let twoParent = this.getParent(two)\n\n    while (oneParent) {\n      ancestors = ancestors.push(oneParent)\n      oneParent = this.getParent(oneParent.key)\n    }\n\n    while (twoParent) {\n      if (ancestors.includes(twoParent)) return twoParent\n      twoParent = this.getParent(twoParent.key)\n    }\n  }\n\n  /**\n   * Get the decorations for the node from a `stack`.\n   *\n   * @param {Stack} stack\n   * @return {List}\n   */\n\n  getDecorations(stack) {\n    const decorations = stack.find('decorateNode', this)\n    const list = Range.createList(decorations || [])\n    return list\n  }\n\n  /**\n   * Get the depth of a child node by `key`, with optional `startAt`.\n   *\n   * @param {String} key\n   * @param {Number} startAt (optional)\n   * @return {Number} depth\n   */\n\n  getDepth(key, startAt = 1) {\n    this.assertDescendant(key)\n    if (this.hasChild(key)) return startAt\n    return this.getFurthestAncestor(key).getDepth(key, startAt + 1)\n  }\n\n  /**\n   * Get a descendant node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getDescendant(key) {\n    key = assertKey(key)\n    let descendantFound = null\n\n    const found = this.nodes.find(node => {\n      if (node.key === key) {\n        return node\n      } else if (node.object !== 'text') {\n        descendantFound = node.getDescendant(key)\n        return descendantFound\n      } else {\n        return false\n      }\n    })\n\n    return descendantFound || found\n  }\n\n  /**\n   * Get a descendant by `path`.\n   *\n   * @param {Array} path\n   * @return {Node|Null}\n   */\n\n  getDescendantAtPath(path) {\n    let descendant = this\n\n    for (const index of path) {\n      if (!descendant) return\n      if (!descendant.nodes) return\n      descendant = descendant.nodes.get(index)\n    }\n\n    return descendant\n  }\n\n  /**\n   * Get the first child text node.\n   *\n   * @return {Node|Null}\n   */\n\n  getFirstText() {\n    let descendantFound = null\n\n    const found = this.nodes.find(node => {\n      if (node.object == 'text') return true\n      descendantFound = node.getFirstText()\n      return descendantFound\n    })\n\n    return descendantFound || found\n  }\n\n  /**\n   * Get a fragment of the node at a `range`.\n   *\n   * @param {Range} range\n   * @return {Document}\n   */\n\n  getFragmentAtRange(range) {\n    range = range.normalize(this)\n    if (range.isUnset) return Document.create()\n\n    let node = this\n\n    // Make sure the children exist.\n    const { startKey, startOffset, endKey, endOffset } = range\n    const startText = node.assertDescendant(startKey)\n    const endText = node.assertDescendant(endKey)\n\n    // Split at the start and end.\n    let child = startText\n    let previous\n    let parent\n\n    while ((parent = node.getParent(child.key))) {\n      const index = parent.nodes.indexOf(child)\n      const position =\n        child.object == 'text' ? startOffset : child.nodes.indexOf(previous)\n\n      parent = parent.splitNode(index, position)\n      node = node.updateNode(parent)\n      previous = parent.nodes.get(index + 1)\n      child = parent\n    }\n\n    child = startKey == endKey ? node.getNextText(startKey) : endText\n\n    while ((parent = node.getParent(child.key))) {\n      const index = parent.nodes.indexOf(child)\n      const position =\n        child.object == 'text'\n          ? startKey == endKey ? endOffset - startOffset : endOffset\n          : child.nodes.indexOf(previous)\n\n      parent = parent.splitNode(index, position)\n      node = node.updateNode(parent)\n      previous = parent.nodes.get(index + 1)\n      child = parent\n    }\n\n    // Get the start and end nodes.\n    const startNode = node.getNextSibling(\n      node.getFurthestAncestor(startKey).key\n    )\n    const endNode =\n      startKey == endKey\n        ? node.getNextSibling(\n            node.getNextSibling(node.getFurthestAncestor(endKey).key).key\n          )\n        : node.getNextSibling(node.getFurthestAncestor(endKey).key)\n\n    // Get children range of nodes from start to end nodes\n    const startIndex = node.nodes.indexOf(startNode)\n    const endIndex = node.nodes.indexOf(endNode)\n    const nodes = node.nodes.slice(startIndex, endIndex)\n\n    // Return a new document fragment.\n    return Document.create({ nodes })\n  }\n\n  /**\n   * Get the furthest parent of a node by `key` that matches an `iterator`.\n   *\n   * @param {String} key\n   * @param {Function} iterator\n   * @return {Node|Null}\n   */\n\n  getFurthest(key, iterator) {\n    const ancestors = this.getAncestors(key)\n    if (!ancestors) {\n      key = assertKey(key)\n      throw new Error(`Could not find a descendant node with key \"${key}\".`)\n    }\n\n    // Exclude this node itself\n    return ancestors.rest().find(iterator)\n  }\n\n  /**\n   * Get the furthest block parent of a node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getFurthestBlock(key) {\n    return this.getFurthest(key, node => node.object == 'block')\n  }\n\n  /**\n   * Get the furthest inline parent of a node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getFurthestInline(key) {\n    return this.getFurthest(key, node => node.object == 'inline')\n  }\n\n  /**\n   * Get the furthest ancestor of a node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getFurthestAncestor(key) {\n    key = assertKey(key)\n    return this.nodes.find(node => {\n      if (node.key == key) return true\n      if (node.object == 'text') return false\n      return node.hasDescendant(key)\n    })\n  }\n\n  /**\n   * Get the furthest ancestor of a node by `key` that has only one child.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getFurthestOnlyChildAncestor(key) {\n    const ancestors = this.getAncestors(key)\n\n    if (!ancestors) {\n      key = assertKey(key)\n      throw new Error(`Could not find a descendant node with key \"${key}\".`)\n    }\n\n    const result = ancestors\n      // Skip this node...\n      .shift()\n      // Take parents until there are more than one child...\n      .reverse()\n      .takeUntil(p => p.nodes.size > 1)\n      // And pick the highest.\n      .last()\n    if (!result) return null\n    return result\n  }\n\n  /**\n   * Get the closest inline nodes for each text node in the node.\n   *\n   * @return {List<Node>}\n   */\n\n  getInlines() {\n    const array = this.getInlinesAsArray()\n    return new List(array)\n  }\n\n  /**\n   * Get the closest inline nodes for each text node in the node, as an array.\n   *\n   * @return {List<Node>}\n   */\n\n  getInlinesAsArray() {\n    let array = []\n\n    this.nodes.forEach(child => {\n      if (child.object == 'text') return\n      if (child.isLeafInline()) {\n        array.push(child)\n      } else {\n        array = array.concat(child.getInlinesAsArray())\n      }\n    })\n\n    return array\n  }\n\n  /**\n   * Get the closest inline nodes for each text node in a `range`.\n   *\n   * @param {Range} range\n   * @return {List<Node>}\n   */\n\n  getInlinesAtRange(range) {\n    const array = this.getInlinesAtRangeAsArray(range)\n    // Remove duplicates by converting it to an `OrderedSet` first.\n    return new List(new OrderedSet(array))\n  }\n\n  /**\n   * Get the closest inline nodes for each text node in a `range` as an array.\n   *\n   * @param {Range} range\n   * @return {Array}\n   */\n\n  getInlinesAtRangeAsArray(range) {\n    range = range.normalize(this)\n    if (range.isUnset) return []\n\n    return this.getTextsAtRangeAsArray(range)\n      .map(text => this.getClosestInline(text.key))\n      .filter(exists => exists)\n  }\n\n  /**\n   * Get all of the leaf inline nodes that match a `type`.\n   *\n   * @param {String} type\n   * @return {List<Node>}\n   */\n\n  getInlinesByType(type) {\n    const array = this.getInlinesByTypeAsArray(type)\n    return new List(array)\n  }\n\n  /**\n   * Get all of the leaf inline nodes that match a `type` as an array.\n   *\n   * @param {String} type\n   * @return {Array}\n   */\n\n  getInlinesByTypeAsArray(type) {\n    return this.nodes.reduce((inlines, node) => {\n      if (node.object == 'text') {\n        return inlines\n      } else if (node.isLeafInline() && node.type == type) {\n        inlines.push(node)\n        return inlines\n      } else {\n        return inlines.concat(node.getInlinesByTypeAsArray(type))\n      }\n    }, [])\n  }\n\n  /**\n   * Return a set of all keys in the node as an array.\n   *\n   * @return {Array<String>}\n   */\n\n  getKeysAsArray() {\n    const keys = []\n\n    this.forEachDescendant(desc => {\n      keys.push(desc.key)\n    })\n\n    return keys\n  }\n\n  /**\n   * Return a set of all keys in the node.\n   *\n   * @return {Set<String>}\n   */\n\n  getKeys() {\n    const keys = this.getKeysAsArray()\n    return new Set(keys)\n  }\n\n  /**\n   * Get the last child text node.\n   *\n   * @return {Node|Null}\n   */\n\n  getLastText() {\n    let descendantFound = null\n\n    const found = this.nodes.findLast(node => {\n      if (node.object == 'text') return true\n      descendantFound = node.getLastText()\n      return descendantFound\n    })\n\n    return descendantFound || found\n  }\n\n  /**\n   * Get all of the marks for all of the characters of every text node.\n   *\n   * @return {Set<Mark>}\n   */\n\n  getMarks() {\n    const array = this.getMarksAsArray()\n    return new Set(array)\n  }\n\n  /**\n   * Get all of the marks for all of the characters of every text node.\n   *\n   * @return {OrderedSet<Mark>}\n   */\n\n  getOrderedMarks() {\n    const array = this.getMarksAsArray()\n    return new OrderedSet(array)\n  }\n\n  /**\n   * Get all of the marks as an array.\n   *\n   * @return {Array}\n   */\n\n  getMarksAsArray() {\n    // PERF: use only one concat rather than multiple concat\n    // becuase one concat is faster\n    const result = []\n    this.nodes.forEach(node => {\n      result.push(node.getMarksAsArray())\n    })\n    return Array.prototype.concat.apply([], result)\n  }\n\n  /**\n   * Get a set of the marks in a `range`.\n   *\n   * @param {Range} range\n   * @return {Set<Mark>}\n   */\n\n  getMarksAtRange(range) {\n    return new Set(this.getOrderedMarksAtRange(range))\n  }\n\n  /**\n   * Get a set of the marks in a `range`.\n   *\n   * @param {Range} range\n   * @return {Set<Mark>}\n   */\n\n  getInsertMarksAtRange(range) {\n    range = range.normalize(this)\n    if (range.isUnset) return Set()\n    if (range.isCollapsed) {\n      // PERF: range is not cachable, use key and offset as proxies for cache\n      return this.getMarksAtPosition(range.startKey, range.startOffset)\n    }\n\n    const text = this.getDescendant(range.startKey)\n    const char = text.characters.get(range.startOffset)\n    if (!char) return Set()\n\n    return char.marks\n  }\n\n  /**\n   * Get a set of the marks in a `range`.\n   *\n   * @param {Range} range\n   * @return {OrderedSet<Mark>}\n   */\n\n  getOrderedMarksAtRange(range) {\n    range = range.normalize(this)\n    if (range.isUnset) return OrderedSet()\n    if (range.isCollapsed) {\n      // PERF: range is not cachable, use key and offset as proxies for cache\n      return this.getMarksAtPosition(range.startKey, range.startOffset)\n    }\n\n    const { startKey, startOffset, endKey, endOffset } = range\n    return this.getOrderedMarksBetweenPositions(\n      startKey,\n      startOffset,\n      endKey,\n      endOffset\n    )\n  }\n\n  /**\n   * Get a set of the marks in a `range`.\n   * PERF: arguments use key and offset for utilizing cache\n   *\n   * @param {string} startKey\n   * @param {number} startOffset\n   * @param {string} endKey\n   * @param {number} endOffset\n   * @returns {OrderedSet<Mark>}\n   */\n\n  getOrderedMarksBetweenPositions(startKey, startOffset, endKey, endOffset) {\n    if (startKey === endKey) {\n      const startText = this.getDescendant(startKey)\n      return startText.getMarksBetweenOffsets(startOffset, endOffset)\n    }\n\n    const texts = this.getTextsBetweenPositionsAsArray(startKey, endKey)\n\n    return OrderedSet().withMutations(result => {\n      texts.forEach(text => {\n        if (text.key === startKey) {\n          result.union(\n            text.getMarksBetweenOffsets(startOffset, text.text.length)\n          )\n        } else if (text.key === endKey) {\n          result.union(text.getMarksBetweenOffsets(0, endOffset))\n        } else {\n          result.union(text.getMarks())\n        }\n      })\n    })\n  }\n\n  /**\n   * Get a set of the active marks in a `range`.\n   *\n   * @param {Range} range\n   * @return {Set<Mark>}\n   */\n\n  getActiveMarksAtRange(range) {\n    range = range.normalize(this)\n    if (range.isUnset) return Set()\n    if (range.isCollapsed) {\n      const { startKey, startOffset } = range\n      return this.getMarksAtPosition(startKey, startOffset).toSet()\n    }\n\n    let { startKey, endKey, startOffset, endOffset } = range\n    let startText = this.getDescendant(startKey)\n\n    if (startKey !== endKey) {\n      while (startKey !== endKey && endOffset === 0) {\n        const endText = this.getPreviousText(endKey)\n        endKey = endText.key\n        endOffset = endText.text.length\n      }\n\n      while (startKey !== endKey && startOffset === startText.text.length) {\n        startText = this.getNextText(startKey)\n        startKey = startText.key\n        startOffset = 0\n      }\n    }\n\n    if (startKey === endKey) {\n      return startText.getActiveMarksBetweenOffsets(startOffset, endOffset)\n    }\n\n    const startMarks = startText.getActiveMarksBetweenOffsets(\n      startOffset,\n      startText.text.length\n    )\n    if (startMarks.size === 0) return Set()\n    const endText = this.getDescendant(endKey)\n    const endMarks = endText.getActiveMarksBetweenOffsets(0, endOffset)\n    let marks = startMarks.intersect(endMarks)\n    // If marks is already empty, the active marks is empty\n    if (marks.size === 0) return marks\n\n    let text = this.getNextText(startKey)\n    while (text.key !== endKey) {\n      if (text.text.length !== 0) {\n        marks = marks.intersect(text.getActiveMarks())\n        if (marks.size === 0) return Set()\n      }\n      text = this.getNextText(text.key)\n    }\n    return marks\n  }\n\n  /**\n   * Get a set of marks in a `position`, the equivalent of a collapsed range\n   *\n   * @param {string} key\n   * @param {number} offset\n   * @return {OrderedSet}\n   */\n\n  getMarksAtPosition(key, offset) {\n    if (offset == 0) {\n      const previous = this.getPreviousText(key)\n      if (!previous || previous.text.length == 0) return OrderedSet()\n      if (this.getClosestBlock(key) !== this.getClosestBlock(previous.key)) {\n        return OrderedSet()\n      }\n\n      const char = previous.characters.last()\n      if (!char) return OrderedSet()\n      return new OrderedSet(char.marks)\n    }\n\n    const text = this.getDescendant(key)\n    const char = text.characters.get(offset - 1)\n    if (!char) return OrderedSet()\n    return new OrderedSet(char.marks)\n  }\n\n  /**\n   * Get all of the marks that match a `type`.\n   *\n   * @param {String} type\n   * @return {Set<Mark>}\n   */\n\n  getMarksByType(type) {\n    const array = this.getMarksByTypeAsArray(type)\n    return new Set(array)\n  }\n\n  /**\n   * Get all of the marks that match a `type`.\n   *\n   * @param {String} type\n   * @return {OrderedSet<Mark>}\n   */\n\n  getOrderedMarksByType(type) {\n    const array = this.getMarksByTypeAsArray(type)\n    return new OrderedSet(array)\n  }\n\n  /**\n   * Get all of the marks that match a `type` as an array.\n   *\n   * @param {String} type\n   * @return {Array}\n   */\n\n  getMarksByTypeAsArray(type) {\n    return this.nodes.reduce((array, node) => {\n      return node.object == 'text'\n        ? array.concat(node.getMarksAsArray().filter(m => m.type == type))\n        : array.concat(node.getMarksByTypeAsArray(type))\n    }, [])\n  }\n\n  /**\n   * Get the block node before a descendant text node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getNextBlock(key) {\n    const child = this.assertDescendant(key)\n    let last\n\n    if (child.object == 'block') {\n      last = child.getLastText()\n    } else {\n      const block = this.getClosestBlock(key)\n      last = block.getLastText()\n    }\n\n    const next = this.getNextText(last.key)\n    if (!next) return null\n\n    return this.getClosestBlock(next.key)\n  }\n\n  /**\n   * Get the node after a descendant by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getNextSibling(key) {\n    key = assertKey(key)\n\n    const parent = this.getParent(key)\n    const after = parent.nodes.skipUntil(child => child.key == key)\n\n    if (after.size == 0) {\n      throw new Error(`Could not find a child node with key \"${key}\".`)\n    }\n    return after.get(1)\n  }\n\n  /**\n   * Get the text node after a descendant text node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getNextText(key) {\n    key = assertKey(key)\n    return this.getTexts()\n      .skipUntil(text => text.key == key)\n      .get(1)\n  }\n\n  /**\n   * Get a node in the tree by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getNode(key) {\n    key = assertKey(key)\n    return this.key == key ? this : this.getDescendant(key)\n  }\n\n  /**\n   * Get a node in the tree by `path`.\n   *\n   * @param {Array} path\n   * @return {Node|Null}\n   */\n\n  getNodeAtPath(path) {\n    return path.length ? this.getDescendantAtPath(path) : this\n  }\n\n  /**\n   * Get the offset for a descendant text node by `key`.\n   *\n   * @param {String} key\n   * @return {Number}\n   */\n\n  getOffset(key) {\n    this.assertDescendant(key)\n\n    // Calculate the offset of the nodes before the highest child.\n    const child = this.getFurthestAncestor(key)\n    const offset = this.nodes\n      .takeUntil(n => n == child)\n      .reduce((memo, n) => memo + n.text.length, 0)\n\n    // Recurse if need be.\n    return this.hasChild(key) ? offset : offset + child.getOffset(key)\n  }\n\n  /**\n   * Get the offset from a `range`.\n   *\n   * @param {Range} range\n   * @return {Number}\n   */\n\n  getOffsetAtRange(range) {\n    range = range.normalize(this)\n\n    if (range.isUnset) {\n      throw new Error('The range cannot be unset to calculcate its offset.')\n    }\n\n    if (range.isExpanded) {\n      throw new Error('The range must be collapsed to calculcate its offset.')\n    }\n\n    const { startKey, startOffset } = range\n    return this.getOffset(startKey) + startOffset\n  }\n\n  /**\n   * Get the parent of a child node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getParent(key) {\n    if (this.hasChild(key)) return this\n\n    let node = null\n\n    this.nodes.find(child => {\n      if (child.object == 'text') {\n        return false\n      } else {\n        node = child.getParent(key)\n        return node\n      }\n    })\n\n    return node\n  }\n\n  /**\n   * Get the path of a descendant node by `key`.\n   *\n   * @param {String|Node} key\n   * @return {Array}\n   */\n\n  getPath(key) {\n    let child = this.assertNode(key)\n    const ancestors = this.getAncestors(key)\n    const path = []\n\n    ancestors.reverse().forEach(ancestor => {\n      const index = ancestor.nodes.indexOf(child)\n      path.unshift(index)\n      child = ancestor\n    })\n\n    return path\n  }\n\n  /**\n   * Refind the path of node if path is changed.\n   *\n   * @param {Array} path\n   * @param {String} key\n   * @return {Array}\n   */\n\n  refindPath(path, key) {\n    const node = this.getDescendantAtPath(path)\n    if (node && node.key === key) {\n      return path\n    }\n\n    return this.getPath(key)\n  }\n\n  /**\n   *\n   * Refind the node with the same node.key after change.\n   *\n   * @param {Array} path\n   * @param {String} key\n   * @return {Node|Void}\n   */\n\n  refindNode(path, key) {\n    const node = this.getDescendantAtPath(path)\n    if (node && node.key === key) {\n      return node\n    }\n\n    return this.getDescendant(key)\n  }\n\n  /**\n   * Get the placeholder for the node from a `schema`.\n   *\n   * @param {Schema} schema\n   * @return {Component|Void}\n   */\n\n  getPlaceholder(schema) {\n    return schema.__getPlaceholder(this)\n  }\n\n  /**\n   * Get the block node before a descendant text node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getPreviousBlock(key) {\n    const child = this.assertDescendant(key)\n    let first\n\n    if (child.object == 'block') {\n      first = child.getFirstText()\n    } else {\n      const block = this.getClosestBlock(key)\n      first = block.getFirstText()\n    }\n\n    const previous = this.getPreviousText(first.key)\n    if (!previous) return null\n\n    return this.getClosestBlock(previous.key)\n  }\n\n  /**\n   * Get the node before a descendant node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getPreviousSibling(key) {\n    key = assertKey(key)\n    const parent = this.getParent(key)\n    const before = parent.nodes.takeUntil(child => child.key == key)\n\n    if (before.size == parent.nodes.size) {\n      throw new Error(`Could not find a child node with key \"${key}\".`)\n    }\n\n    return before.last()\n  }\n\n  /**\n   * Get the text node before a descendant text node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getPreviousText(key) {\n    key = assertKey(key)\n    return this.getTexts()\n      .takeUntil(text => text.key == key)\n      .last()\n  }\n\n  /**\n   * Get the indexes of the selection for a `range`, given an extra flag for\n   * whether the node `isSelected`, to determine whether not finding matches\n   * means everything is selected or nothing is.\n   *\n   * @param {Range} range\n   * @param {Boolean} isSelected\n   * @return {Object|Null}\n   */\n\n  getSelectionIndexes(range, isSelected = false) {\n    const { startKey, endKey } = range\n\n    // PERF: if we're not selected, or the range is blurred, we can exit early.\n    if (!isSelected || range.isBlurred) {\n      return null\n    }\n\n    // if we've been given an invalid selection we can exit early.\n    if (range.isUnset) {\n      return null\n    }\n\n    // PERF: if the start and end keys are the same, just check for the child\n    // that contains that single key.\n    if (startKey == endKey) {\n      const child = this.getFurthestAncestor(startKey)\n      const index = child ? this.nodes.indexOf(child) : null\n      return { start: index, end: index + 1 }\n    }\n\n    // Otherwise, check all of the children...\n    let start = null\n    let end = null\n\n    this.nodes.forEach((child, i) => {\n      if (child.object == 'text') {\n        if (start == null && child.key == startKey) start = i\n        if (end == null && child.key == endKey) end = i + 1\n      } else {\n        if (start == null && child.hasDescendant(startKey)) start = i\n        if (end == null && child.hasDescendant(endKey)) end = i + 1\n      }\n\n      // PERF: exit early if both start and end have been found.\n      return start == null || end == null\n    })\n\n    if (isSelected && start == null) start = 0\n    if (isSelected && end == null) end = this.nodes.size\n    return start == null ? null : { start, end }\n  }\n\n  /**\n   * Get the concatenated text string of all child nodes.\n   *\n   * @return {String}\n   */\n\n  getText() {\n    return this.nodes.reduce((string, node) => {\n      return string + node.text\n    }, '')\n  }\n\n  /**\n   * Get the descendent text node at an `offset`.\n   *\n   * @param {String} offset\n   * @return {Node|Null}\n   */\n\n  getTextAtOffset(offset) {\n    // PERF: Add a few shortcuts for the obvious cases.\n    if (offset == 0) return this.getFirstText()\n    if (offset == this.text.length) return this.getLastText()\n    if (offset < 0 || offset > this.text.length) return null\n\n    let length = 0\n\n    return this.getTexts().find((node, i, nodes) => {\n      length += node.text.length\n      return length > offset\n    })\n  }\n\n  /**\n   * Get the direction of the node's text.\n   *\n   * @return {String}\n   */\n\n  getTextDirection() {\n    const dir = direction(this.text)\n    return dir == 'neutral' ? undefined : dir\n  }\n\n  /**\n   * Recursively get all of the child text nodes in order of appearance.\n   *\n   * @return {List<Node>}\n   */\n\n  getTexts() {\n    const array = this.getTextsAsArray()\n    return new List(array)\n  }\n\n  /**\n   * Recursively get all the leaf text nodes in order of appearance, as array.\n   *\n   * @return {List<Node>}\n   */\n\n  getTextsAsArray() {\n    let array = []\n\n    this.nodes.forEach(node => {\n      if (node.object == 'text') {\n        array.push(node)\n      } else {\n        array = array.concat(node.getTextsAsArray())\n      }\n    })\n\n    return array\n  }\n\n  /**\n   * Get all of the text nodes in a `range`.\n   *\n   * @param {Range} range\n   * @return {List<Node>}\n   */\n\n  getTextsAtRange(range) {\n    range = range.normalize(this)\n    if (range.isUnset) return List()\n    const { startKey, endKey } = range\n    return new List(this.getTextsBetweenPositionsAsArray(startKey, endKey))\n  }\n\n  /**\n   * Get all of the text nodes in a `range` as an array.\n   * PERF: use key in arguments for cache\n   *\n   * @param {string} startKey\n   * @param {string} endKey\n   * @returns {Array}\n   */\n\n  getTextsBetweenPositionsAsArray(startKey, endKey) {\n    const startText = this.getDescendant(startKey)\n\n    // PERF: the most common case is when the range is in a single text node,\n    // where we can avoid a lot of iterating of the tree.\n    if (startKey == endKey) return [startText]\n\n    const endText = this.getDescendant(endKey)\n    const texts = this.getTextsAsArray()\n    const start = texts.indexOf(startText)\n    const end = texts.indexOf(endText, start)\n    return texts.slice(start, end + 1)\n  }\n\n  /**\n   * Get all of the text nodes in a `range` as an array.\n   *\n   * @param {Range} range\n   * @return {Array}\n   */\n\n  getTextsAtRangeAsArray(range) {\n    range = range.normalize(this)\n    if (range.isUnset) return []\n    const { startKey, endKey } = range\n    return this.getTextsBetweenPositionsAsArray(startKey, endKey)\n  }\n\n  /**\n   * Check if a child node exists by `key`.\n   *\n   * @param {String} key\n   * @return {Boolean}\n   */\n\n  hasChild(key) {\n    return !!this.getChild(key)\n  }\n\n  /**\n   * Check if a node has block node children.\n   *\n   * @param {String} key\n   * @return {Boolean}\n   */\n\n  hasBlocks(key) {\n    const node = this.assertNode(key)\n    return !!(node.nodes && node.nodes.find(n => n.object === 'block'))\n  }\n\n  /**\n   * Check if a node has inline node children.\n   *\n   * @param {String} key\n   * @return {Boolean}\n   */\n\n  hasInlines(key) {\n    const node = this.assertNode(key)\n    return !!(\n      node.nodes && node.nodes.find(n => Inline.isInline(n) || Text.isText(n))\n    )\n  }\n\n  /**\n   * Recursively check if a child node exists by `key`.\n   *\n   * @param {String} key\n   * @return {Boolean}\n   */\n\n  hasDescendant(key) {\n    return !!this.getDescendant(key)\n  }\n\n  /**\n   * Recursively check if a node exists by `key`.\n   *\n   * @param {String} key\n   * @return {Boolean}\n   */\n\n  hasNode(key) {\n    return !!this.getNode(key)\n  }\n\n  /**\n   * Check if a node has a void parent by `key`.\n   *\n   * @param {String} key\n   * @return {Boolean}\n   */\n\n  hasVoidParent(key) {\n    return !!this.getClosestVoid(key)\n  }\n\n  /**\n   * Insert a `node` at `index`.\n   *\n   * @param {Number} index\n   * @param {Node} node\n   * @return {Node}\n   */\n\n  insertNode(index, node) {\n    const keys = this.getKeysAsArray()\n\n    if (keys.includes(node.key)) {\n      node = node.regenerateKey()\n    }\n\n    if (node.object != 'text') {\n      node = node.mapDescendants(desc => {\n        return keys.includes(desc.key) ? desc.regenerateKey() : desc\n      })\n    }\n\n    const nodes = this.nodes.insert(index, node)\n    return this.set('nodes', nodes)\n  }\n\n  /**\n   * Check whether the node is in a `range`.\n   *\n   * @param {Range} range\n   * @return {Boolean}\n   */\n\n  isInRange(range) {\n    range = range.normalize(this)\n\n    const node = this\n    const { startKey, endKey, isCollapsed } = range\n\n    // PERF: solve the most common cast where the start or end key are inside\n    // the node, for collapsed selections.\n    if (\n      node.key == startKey ||\n      node.key == endKey ||\n      node.hasDescendant(startKey) ||\n      node.hasDescendant(endKey)\n    ) {\n      return true\n    }\n\n    // PERF: if the selection is collapsed and the previous check didn't return\n    // true, then it must be false.\n    if (isCollapsed) {\n      return false\n    }\n\n    // Otherwise, look through all of the leaf text nodes in the range, to see\n    // if any of them are inside the node.\n    const texts = node.getTextsAtRange(range)\n    let memo = false\n\n    texts.forEach(text => {\n      if (node.hasDescendant(text.key)) memo = true\n      return memo\n    })\n\n    return memo\n  }\n\n  /**\n   * Check whether the node is a leaf block.\n   *\n   * @return {Boolean}\n   */\n\n  isLeafBlock() {\n    return this.object == 'block' && this.nodes.every(n => n.object != 'block')\n  }\n\n  /**\n   * Check whether the node is a leaf inline.\n   *\n   * @return {Boolean}\n   */\n\n  isLeafInline() {\n    return (\n      this.object == 'inline' && this.nodes.every(n => n.object != 'inline')\n    )\n  }\n\n  /**\n   * Merge a children node `first` with another children node `second`.\n   * `first` and `second` will be concatenated in that order.\n   * `first` and `second` must be two Nodes or two Text.\n   *\n   * @param {Node} first\n   * @param {Node} second\n   * @return {Node}\n   */\n\n  mergeNode(withIndex, index) {\n    let node = this\n    let one = node.nodes.get(withIndex)\n    const two = node.nodes.get(index)\n\n    if (one.object != two.object) {\n      throw new Error(\n        `Tried to merge two nodes of different objects: \"${one.object}\" and \"${\n          two.object\n        }\".`\n      )\n    }\n\n    // If the nodes are text nodes, concatenate their characters together.\n    if (one.object == 'text') {\n      const characters = one.characters.concat(two.characters)\n      one = one.set('characters', characters)\n    } else {\n      // Otherwise, concatenate their child nodes together.\n      const nodes = one.nodes.concat(two.nodes)\n      one = one.set('nodes', nodes)\n    }\n\n    node = node.removeNode(index)\n    node = node.removeNode(withIndex)\n    node = node.insertNode(withIndex, one)\n    return node\n  }\n\n  /**\n   * Map all child nodes, updating them in their parents. This method is\n   * optimized to not return a new node if no changes are made.\n   *\n   * @param {Function} iterator\n   * @return {Node}\n   */\n\n  mapChildren(iterator) {\n    let { nodes } = this\n\n    nodes.forEach((node, i) => {\n      const ret = iterator(node, i, this.nodes)\n      if (ret != node) nodes = nodes.set(ret.key, ret)\n    })\n\n    return this.set('nodes', nodes)\n  }\n\n  /**\n   * Map all descendant nodes, updating them in their parents. This method is\n   * optimized to not return a new node if no changes are made.\n   *\n   * @param {Function} iterator\n   * @return {Node}\n   */\n\n  mapDescendants(iterator) {\n    let { nodes } = this\n\n    nodes.forEach((node, index) => {\n      let ret = node\n      if (ret.object != 'text') ret = ret.mapDescendants(iterator)\n      ret = iterator(ret, index, this.nodes)\n      if (ret == node) return\n\n      nodes = nodes.set(index, ret)\n    })\n\n    return this.set('nodes', nodes)\n  }\n\n  /**\n   * Regenerate the node's key.\n   *\n   * @return {Node}\n   */\n\n  regenerateKey() {\n    const key = generateKey()\n    return this.set('key', key)\n  }\n\n  /**\n   * Remove a `node` from the children node map.\n   *\n   * @param {String} key\n   * @return {Node}\n   */\n\n  removeDescendant(key) {\n    key = assertKey(key)\n\n    let node = this\n    let parent = node.getParent(key)\n    if (!parent)\n      throw new Error(`Could not find a descendant node with key \"${key}\".`)\n\n    const index = parent.nodes.findIndex(n => n.key === key)\n    const nodes = parent.nodes.splice(index, 1)\n\n    parent = parent.set('nodes', nodes)\n    node = node.updateNode(parent)\n    return node\n  }\n\n  /**\n   * Remove a node at `index`.\n   *\n   * @param {Number} index\n   * @return {Node}\n   */\n\n  removeNode(index) {\n    const nodes = this.nodes.splice(index, 1)\n    return this.set('nodes', nodes)\n  }\n\n  /**\n   * Split a child node by `index` at `position`.\n   *\n   * @param {Number} index\n   * @param {Number} position\n   * @return {Node}\n   */\n\n  splitNode(index, position) {\n    let node = this\n    const child = node.nodes.get(index)\n    let one\n    let two\n\n    // If the child is a text node, the `position` refers to the text offset at\n    // which to split it.\n    if (child.object == 'text') {\n      const befores = child.characters.take(position)\n      const afters = child.characters.skip(position)\n      one = child.set('characters', befores)\n      two = child.set('characters', afters).regenerateKey()\n    } else {\n      // Otherwise, if the child is not a text node, the `position` refers to the\n      // index at which to split its children.\n      const befores = child.nodes.take(position)\n      const afters = child.nodes.skip(position)\n      one = child.set('nodes', befores)\n      two = child.set('nodes', afters).regenerateKey()\n    }\n\n    // Remove the old node and insert the newly split children.\n    node = node.removeNode(index)\n    node = node.insertNode(index, two)\n    node = node.insertNode(index, one)\n    return node\n  }\n\n  /**\n   * Set a new value for a child node by `key`.\n   *\n   * @param {Node} node\n   * @return {Node}\n   */\n\n  updateNode(node) {\n    if (node.key == this.key) {\n      return node\n    }\n\n    let child = this.assertDescendant(node.key)\n    const ancestors = this.getAncestors(node.key)\n\n    ancestors.reverse().forEach(parent => {\n      let { nodes } = parent\n      const index = nodes.indexOf(child)\n      child = parent\n      nodes = nodes.set(index, node)\n      parent = parent.set('nodes', nodes)\n      node = parent\n    })\n\n    return node\n  }\n\n  /**\n   * Validate the node against a `schema`.\n   *\n   * @param {Schema} schema\n   * @return {Function|Null}\n   */\n\n  validate(schema) {\n    return schema.validateNode(this)\n  }\n\n  /**\n   * Get the first invalid descendant\n   *\n   * @param {Schema} schema\n   * @return {Node|Text|Null}\n   */\n\n  getFirstInvalidDescendant(schema) {\n    let result = null\n    this.nodes.find(n => {\n      result = n.validate(schema) ? n : n.getFirstInvalidDescendant(schema)\n      return result\n    })\n    return result\n  }\n}\n\n/**\n * Assert a key `arg`.\n *\n * @param {String} arg\n * @return {String}\n */\n\nfunction assertKey(arg) {\n  if (typeof arg == 'string') return arg\n  throw new Error(\n    `Invalid \\`key\\` argument! It must be a key string, but you passed: ${arg}`\n  )\n}\n\n/**\n * Memoize read methods.\n */\n\nmemoize(Node.prototype, [\n  'areDescendantsSorted',\n  'getAncestors',\n  'getBlocksAsArray',\n  'getBlocksAtRangeAsArray',\n  'getBlocksByTypeAsArray',\n  'getChild',\n  'getClosestBlock',\n  'getClosestInline',\n  'getClosestVoid',\n  'getCommonAncestor',\n  'getDecorations',\n  'getDepth',\n  'getDescendant',\n  'getDescendantAtPath',\n  'getFirstText',\n  'getFragmentAtRange',\n  'getFurthestBlock',\n  'getFurthestInline',\n  'getFurthestAncestor',\n  'getFurthestOnlyChildAncestor',\n  'getInlinesAsArray',\n  'getInlinesAtRangeAsArray',\n  'getInlinesByTypeAsArray',\n  'getMarksAsArray',\n  'getMarksAtPosition',\n  'getOrderedMarksBetweenPositions',\n  'getInsertMarksAtRange',\n  'getKeysAsArray',\n  'getLastText',\n  'getMarksByTypeAsArray',\n  'getNextBlock',\n  'getNextSibling',\n  'getNextText',\n  'getNode',\n  'getNodeAtPath',\n  'getOffset',\n  'getOffsetAtRange',\n  'getParent',\n  'getPath',\n  'getPlaceholder',\n  'getPreviousBlock',\n  'getPreviousSibling',\n  'getPreviousText',\n  'getText',\n  'getTextAtOffset',\n  'getTextDirection',\n  'getTextsAsArray',\n  'getTextsBetweenPositionsAsArray',\n  'isLeafBlock',\n  'isLeafInline',\n  'validate',\n  'getFirstInvalidDescendant',\n])\n\n/**\n * Mix in `Node` methods.\n */\n\nObject.getOwnPropertyNames(Node.prototype).forEach(method => {\n  if (method == 'constructor') return\n  Block.prototype[method] = Node.prototype[method]\n  Inline.prototype[method] = Node.prototype[method]\n  Document.prototype[method] = Node.prototype[method]\n})\n\nBlock.createChildren = Node.createList\nInline.createChildren = Node.createList\nDocument.createChildren = Node.createList\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Node\n","import { reverse } from 'esrever'\n\n/**\n * Surrogate pair start and end points.\n *\n * @type {Number}\n */\n\nconst SURROGATE_START = 0xd800\nconst SURROGATE_END = 0xdfff\n\n/**\n * A regex to match space characters.\n *\n * @type {RegExp}\n */\n\nconst SPACE = /\\s/\n\n/**\n * A regex to match chameleon characters, that count as word characters as long\n * as they are inside of a word.\n *\n * @type {RegExp}\n */\n\nconst CHAMELEON = /['\\u2018\\u2019]/\n\n/**\n * A regex that matches punctuation.\n *\n * @type {RegExp}\n */\n\nconst PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\n\n/**\n * Is a character `code` in a surrogate character.\n *\n * @param {Number} code\n * @return {Boolean}\n */\n\nfunction isSurrogate(code) {\n  return SURROGATE_START <= code && code <= SURROGATE_END\n}\n\n/**\n * Is a character a word character? Needs the `remaining` characters too.\n *\n * @param {String} char\n * @param {String|Void} remaining\n * @return {Boolean}\n */\n\nfunction isWord(char, remaining) {\n  if (SPACE.test(char)) return false\n\n  // If it's a chameleon character, recurse to see if the next one is or not.\n  if (CHAMELEON.test(char)) {\n    let next = remaining.charAt(0)\n    const length = getCharLength(next)\n    next = remaining.slice(0, length)\n    const rest = remaining.slice(length)\n    if (isWord(next, rest)) return true\n  }\n\n  if (PUNCTUATION.test(char)) return false\n  return true\n}\n\n/**\n * Get the length of a `character`.\n *\n * @param {String} char\n * @return {Number}\n */\n\nfunction getCharLength(char) {\n  return isSurrogate(char.charCodeAt(0)) ? 2 : 1\n}\n\n/**\n * Get the offset to the end of the first character in `text`.\n *\n * @param {String} text\n * @return {Number}\n */\n\nfunction getCharOffset(text) {\n  const char = text.charAt(0)\n  return getCharLength(char)\n}\n\n/**\n * Get the offset to the end of the character before an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getCharOffsetBackward(text, offset) {\n  text = text.slice(0, offset)\n  text = reverse(text)\n  return getCharOffset(text)\n}\n\n/**\n * Get the offset to the end of the character after an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getCharOffsetForward(text, offset) {\n  text = text.slice(offset)\n  return getCharOffset(text)\n}\n\n/**\n * Get the offset to the end of the first word in `text`.\n *\n * @param {String} text\n * @return {Number}\n */\n\nfunction getWordOffset(text) {\n  let length = 0\n  let i = 0\n  let started = false\n  let char\n\n  while ((char = text.charAt(i))) {\n    const l = getCharLength(char)\n    char = text.slice(i, i + l)\n    const rest = text.slice(i + l)\n\n    if (isWord(char, rest)) {\n      started = true\n      length += l\n    } else if (!started) {\n      length += l\n    } else {\n      break\n    }\n\n    i += l\n  }\n\n  return length\n}\n\n/**\n * Get the offset to the end of the word before an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getWordOffsetBackward(text, offset) {\n  text = text.slice(0, offset)\n  text = reverse(text)\n  const o = getWordOffset(text)\n  return o\n}\n\n/**\n * Get the offset to the end of the word after an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getWordOffsetForward(text, offset) {\n  text = text.slice(offset)\n  const o = getWordOffset(text)\n  return o\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n  getCharOffsetForward,\n  getCharOffsetBackward,\n  getWordOffsetBackward,\n  getWordOffsetForward,\n}\n","import { List } from 'immutable'\nimport logger from 'slate-dev-logger'\n\nimport Block from '../models/block'\nimport Inline from '../models/inline'\nimport Mark from '../models/mark'\nimport Node from '../models/node'\nimport String from '../utils/string'\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nconst Changes = {}\n\n/**\n * Add a new `mark` to the characters at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Mixed} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.addMarkAtRange = (change, range, mark, options = {}) => {\n  if (range.isCollapsed) return\n\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset, endKey, endOffset } = range\n  const texts = document.getTextsAtRange(range)\n\n  texts.forEach(node => {\n    const { key } = node\n    let index = 0\n    let length = node.text.length\n\n    if (key == startKey) index = startOffset\n    if (key == endKey) length = endOffset\n    if (key == startKey && key == endKey) length = endOffset - startOffset\n\n    change.addMarkByKey(key, index, length, mark, { normalize })\n  })\n}\n\n/**\n * Add a list of `marks` to the characters at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Array<Mixed>} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.addMarksAtRange = (change, range, marks, options = {}) => {\n  marks.forEach(mark => change.addMarkAtRange(range, mark, options))\n}\n\n/**\n * Delete everything in a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteAtRange = (change, range, options = {}) => {\n  if (range.isCollapsed) return\n\n  // Snapshot the selection, which creates an extra undo save point, so that\n  // when you undo a delete, the expanded selection will be retained.\n  change.snapshotSelection()\n\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  let { startKey, startOffset, endKey, endOffset } = range\n  let { document } = value\n  let isStartVoid = document.hasVoidParent(startKey)\n  let isEndVoid = document.hasVoidParent(endKey)\n  let startBlock = document.getClosestBlock(startKey)\n  let endBlock = document.getClosestBlock(endKey)\n\n  // Check if we have a \"hanging\" selection case where the even though the\n  // selection extends into the start of the end node, we actually want to\n  // ignore that for UX reasons.\n  const isHanging =\n    startOffset == 0 &&\n    endOffset == 0 &&\n    isStartVoid == false &&\n    startKey == startBlock.getFirstText().key &&\n    endKey == endBlock.getFirstText().key\n\n  // If it's a hanging selection, nudge it back to end in the previous text.\n  if (isHanging && isEndVoid) {\n    const prevText = document.getPreviousText(endKey)\n    endKey = prevText.key\n    endOffset = prevText.text.length\n    isEndVoid = document.hasVoidParent(endKey)\n  }\n\n  // If the start node is inside a void node, remove the void node and update\n  // the starting point to be right after it, continuously until the start point\n  // is not a void, or until the entire range is handled.\n  while (isStartVoid) {\n    const startVoid = document.getClosestVoid(startKey)\n    const nextText = document.getNextText(startKey)\n    change.removeNodeByKey(startVoid.key, { normalize: false })\n\n    // If the start and end keys are the same, we're done.\n    if (startKey == endKey) return\n\n    // If there is no next text node, we're done.\n    if (!nextText) return\n\n    // Continue...\n    document = change.value.document\n    startKey = nextText.key\n    startOffset = 0\n    isStartVoid = document.hasVoidParent(startKey)\n  }\n\n  // If the end node is inside a void node, do the same thing but backwards. But\n  // we don't need any aborting checks because if we've gotten this far there\n  // must be a non-void node that will exit the loop.\n  while (isEndVoid) {\n    const endVoid = document.getClosestVoid(endKey)\n    const prevText = document.getPreviousText(endKey)\n    change.removeNodeByKey(endVoid.key, { normalize: false })\n\n    // Continue...\n    document = change.value.document\n    endKey = prevText.key\n    endOffset = prevText.text.length\n    isEndVoid = document.hasVoidParent(endKey)\n  }\n\n  // If the start and end key are the same, and it was a hanging selection, we\n  // can just remove the entire block.\n  if (startKey == endKey && isHanging) {\n    change.removeNodeByKey(startBlock.key, { normalize })\n    return\n  } else if (startKey == endKey) {\n    // Otherwise, if it wasn't hanging, we're inside a single text node, so we can\n    // simply remove the text in the range.\n    const index = startOffset\n    const length = endOffset - startOffset\n    change.removeTextByKey(startKey, index, length, { normalize })\n    return\n  } else {\n    // Otherwise, we need to recursively remove text and nodes inside the start\n    // block after the start offset and inside the end block before the end\n    // offset. Then remove any blocks that are in between the start and end\n    // blocks. Then finally merge the start and end nodes.\n    startBlock = document.getClosestBlock(startKey)\n    endBlock = document.getClosestBlock(endKey)\n    const startText = document.getNode(startKey)\n    const endText = document.getNode(endKey)\n    const startLength = startText.text.length - startOffset\n    const endLength = endOffset\n\n    const ancestor = document.getCommonAncestor(startKey, endKey)\n    const startChild = ancestor.getFurthestAncestor(startKey)\n    const endChild = ancestor.getFurthestAncestor(endKey)\n\n    const startParent = document.getParent(startBlock.key)\n    const startParentIndex = startParent.nodes.indexOf(startBlock)\n    const endParentIndex = startParent.nodes.indexOf(endBlock)\n\n    let child\n\n    // Iterate through all of the nodes in the tree after the start text node\n    // but inside the end child, and remove them.\n    child = startText\n\n    while (child.key != startChild.key) {\n      const parent = document.getParent(child.key)\n      const index = parent.nodes.indexOf(child)\n      const afters = parent.nodes.slice(index + 1)\n\n      afters.reverse().forEach(node => {\n        change.removeNodeByKey(node.key, { normalize: false })\n      })\n\n      child = parent\n    }\n\n    // Remove all of the middle children.\n    const startChildIndex = ancestor.nodes.indexOf(startChild)\n    const endChildIndex = ancestor.nodes.indexOf(endChild)\n    const middles = ancestor.nodes.slice(startChildIndex + 1, endChildIndex)\n\n    middles.reverse().forEach(node => {\n      change.removeNodeByKey(node.key, { normalize: false })\n    })\n\n    // Remove the nodes before the end text node in the tree.\n    child = endText\n\n    while (child.key != endChild.key) {\n      const parent = document.getParent(child.key)\n      const index = parent.nodes.indexOf(child)\n      const befores = parent.nodes.slice(0, index)\n\n      befores.reverse().forEach(node => {\n        change.removeNodeByKey(node.key, { normalize: false })\n      })\n\n      child = parent\n    }\n\n    // Remove any overlapping text content from the leaf text nodes.\n    if (startLength != 0) {\n      change.removeTextByKey(startKey, startOffset, startLength, {\n        normalize: false,\n      })\n    }\n\n    if (endLength != 0) {\n      change.removeTextByKey(endKey, 0, endOffset, { normalize: false })\n    }\n\n    // If the start and end blocks aren't the same, move and merge the end block\n    // into the start block.\n    if (startBlock.key != endBlock.key) {\n      document = change.value.document\n      const lonely = document.getFurthestOnlyChildAncestor(endBlock.key)\n\n      // Move the end block to be right after the start block.\n      if (endParentIndex != startParentIndex + 1) {\n        change.moveNodeByKey(\n          endBlock.key,\n          startParent.key,\n          startParentIndex + 1,\n          { normalize: false }\n        )\n      }\n\n      // If the selection is hanging, just remove the start block, otherwise\n      // merge the end block into it.\n      if (isHanging) {\n        change.removeNodeByKey(startBlock.key, { normalize: false })\n      } else {\n        change.mergeNodeByKey(endBlock.key, { normalize: false })\n      }\n\n      // If nested empty blocks are left over above the end block, remove them.\n      if (lonely) {\n        change.removeNodeByKey(lonely.key, { normalize: false })\n      }\n    }\n\n    // If we should normalize, do it now after everything.\n    if (normalize) {\n      change.normalizeNodeByKey(ancestor.key)\n    }\n  }\n}\n\n/**\n * Delete backward until the character boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteCharBackwardAtRange = (change, range, options) => {\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset } = range\n  const startBlock = document.getClosestBlock(startKey)\n  const offset = startBlock.getOffset(startKey)\n  const o = offset + startOffset\n  const { text } = startBlock\n  const n = String.getCharOffsetBackward(text, o)\n  change.deleteBackwardAtRange(range, n, options)\n}\n\n/**\n * Delete backward until the line boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteLineBackwardAtRange = (change, range, options) => {\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset } = range\n  const startBlock = document.getClosestBlock(startKey)\n  const offset = startBlock.getOffset(startKey)\n  const o = offset + startOffset\n  change.deleteBackwardAtRange(range, o, options)\n}\n\n/**\n * Delete backward until the word boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteWordBackwardAtRange = (change, range, options) => {\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset } = range\n  const startBlock = document.getClosestBlock(startKey)\n  const offset = startBlock.getOffset(startKey)\n  const o = offset + startOffset\n  const { text } = startBlock\n  const n = String.getWordOffsetBackward(text, o)\n  change.deleteBackwardAtRange(range, n, options)\n}\n\n/**\n * Delete backward `n` characters at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Number} n (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteBackwardAtRange = (change, range, n = 1, options = {}) => {\n  if (n === 0) return\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const { startKey, focusOffset } = range\n\n  // If the range is expanded, perform a regular delete instead.\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize })\n    return\n  }\n\n  const voidParent = document.getClosestVoid(startKey)\n\n  // If there is a void parent, delete it.\n  if (voidParent) {\n    change.removeNodeByKey(voidParent.key, { normalize })\n    return\n  }\n\n  const block = document.getClosestBlock(startKey)\n\n  // If the closest is not void, but empty, remove it\n  if (block && block.isEmpty && document.nodes.size !== 1) {\n    change.removeNodeByKey(block.key, { normalize })\n    return\n  }\n\n  // If the range is at the start of the document, abort.\n  if (range.isAtStartOf(document)) {\n    return\n  }\n\n  // If the range is at the start of the text node, we need to figure out what\n  // is behind it to know how to delete...\n  const text = document.getDescendant(startKey)\n  if (range.isAtStartOf(text)) {\n    const prev = document.getPreviousText(text.key)\n    const prevBlock = document.getClosestBlock(prev.key)\n    const prevVoid = document.getClosestVoid(prev.key)\n\n    // If the previous text node has a void parent, remove it.\n    if (prevVoid) {\n      change.removeNodeByKey(prevVoid.key, { normalize })\n      return\n    }\n\n    // If we're deleting by one character and the previous text node is not\n    // inside the current block, we need to merge the two blocks together.\n    if (n == 1 && prevBlock != block) {\n      range = range.merge({\n        anchorKey: prev.key,\n        anchorOffset: prev.text.length,\n      })\n\n      change.deleteAtRange(range, { normalize })\n      return\n    }\n  }\n\n  // If the focus offset is farther than the number of characters to delete,\n  // just remove the characters backwards inside the current node.\n  if (n < focusOffset) {\n    range = range.merge({\n      focusOffset: focusOffset - n,\n      isBackward: true,\n    })\n\n    change.deleteAtRange(range, { normalize })\n    return\n  }\n\n  // Otherwise, we need to see how many nodes backwards to go.\n  let node = text\n  let offset = 0\n  let traversed = focusOffset\n\n  while (n > traversed) {\n    node = document.getPreviousText(node.key)\n    const next = traversed + node.text.length\n    if (n <= next) {\n      offset = next - n\n      break\n    } else {\n      traversed = next\n    }\n  }\n\n  range = range.merge({\n    focusKey: node.key,\n    focusOffset: offset,\n    isBackward: true,\n  })\n\n  change.deleteAtRange(range, { normalize })\n}\n\n/**\n * Delete forward until the character boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteCharForwardAtRange = (change, range, options) => {\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset } = range\n  const startBlock = document.getClosestBlock(startKey)\n  const offset = startBlock.getOffset(startKey)\n  const o = offset + startOffset\n  const { text } = startBlock\n  const n = String.getCharOffsetForward(text, o)\n  change.deleteForwardAtRange(range, n, options)\n}\n\n/**\n * Delete forward until the line boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteLineForwardAtRange = (change, range, options) => {\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset } = range\n  const startBlock = document.getClosestBlock(startKey)\n  const offset = startBlock.getOffset(startKey)\n  const o = offset + startOffset\n  change.deleteForwardAtRange(range, startBlock.text.length - o, options)\n}\n\n/**\n * Delete forward until the word boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteWordForwardAtRange = (change, range, options) => {\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset } = range\n  const startBlock = document.getClosestBlock(startKey)\n  const offset = startBlock.getOffset(startKey)\n  const o = offset + startOffset\n  const { text } = startBlock\n  const n = String.getWordOffsetForward(text, o)\n  change.deleteForwardAtRange(range, n, options)\n}\n\n/**\n * Delete forward `n` characters at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Number} n (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteForwardAtRange = (change, range, n = 1, options = {}) => {\n  if (n === 0) return\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const { startKey, focusOffset } = range\n\n  // If the range is expanded, perform a regular delete instead.\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize })\n    return\n  }\n\n  const voidParent = document.getClosestVoid(startKey)\n\n  // If the node has a void parent, delete it.\n  if (voidParent) {\n    change.removeNodeByKey(voidParent.key, { normalize })\n    return\n  }\n\n  const block = document.getClosestBlock(startKey)\n\n  // If the closest is not void, but empty, remove it\n  if (block && block.isEmpty && document.nodes.size !== 1) {\n    const nextBlock = document.getNextBlock(block.key)\n    change.removeNodeByKey(block.key, { normalize })\n    if (nextBlock && nextBlock.key) {\n      change.moveToStartOf(nextBlock)\n    }\n    return\n  }\n\n  // If the range is at the start of the document, abort.\n  if (range.isAtEndOf(document)) {\n    return\n  }\n\n  // If the range is at the start of the text node, we need to figure out what\n  // is behind it to know how to delete...\n  const text = document.getDescendant(startKey)\n  if (range.isAtEndOf(text)) {\n    const next = document.getNextText(text.key)\n    const nextBlock = document.getClosestBlock(next.key)\n    const nextVoid = document.getClosestVoid(next.key)\n\n    // If the next text node has a void parent, remove it.\n    if (nextVoid) {\n      change.removeNodeByKey(nextVoid.key, { normalize })\n      return\n    }\n\n    // If we're deleting by one character and the previous text node is not\n    // inside the current block, we need to merge the two blocks together.\n    if (n == 1 && nextBlock != block) {\n      range = range.merge({\n        focusKey: next.key,\n        focusOffset: 0,\n      })\n\n      change.deleteAtRange(range, { normalize })\n      return\n    }\n  }\n\n  // If the remaining characters to the end of the node is greater than or equal\n  // to the number of characters to delete, just remove the characters forwards\n  // inside the current node.\n  if (n <= text.text.length - focusOffset) {\n    range = range.merge({\n      focusOffset: focusOffset + n,\n    })\n\n    change.deleteAtRange(range, { normalize })\n    return\n  }\n\n  // Otherwise, we need to see how many nodes forwards to go.\n  let node = text\n  let offset = focusOffset\n  let traversed = text.text.length - focusOffset\n\n  while (n > traversed) {\n    node = document.getNextText(node.key)\n    const next = traversed + node.text.length\n    if (n <= next) {\n      offset = n - traversed\n      break\n    } else {\n      traversed = next\n    }\n  }\n\n  // If the focus node is inside a void, go up until right before it.\n  if (document.hasVoidParent(node.key)) {\n    const parent = document.getClosestVoid(node.key)\n    node = document.getPreviousText(parent.key)\n    offset = node.text.length\n  }\n\n  range = range.merge({\n    focusKey: node.key,\n    focusOffset: offset,\n  })\n\n  change.deleteAtRange(range, { normalize })\n}\n\n/**\n * Insert a `block` node at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Block|String|Object} block\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.insertBlockAtRange = (change, range, block, options = {}) => {\n  block = Block.create(block)\n  const normalize = change.getFlag('normalize', options)\n\n  if (range.isExpanded) {\n    change.deleteAtRange(range)\n    range = range.collapseToStart()\n  }\n\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset } = range\n  const startBlock = document.getClosestBlock(startKey)\n  const parent = document.getParent(startBlock.key)\n  const index = parent.nodes.indexOf(startBlock)\n\n  if (startBlock.isVoid) {\n    const extra = range.isAtEndOf(startBlock) ? 1 : 0\n    change.insertNodeByKey(parent.key, index + extra, block, { normalize })\n  } else if (startBlock.isEmpty) {\n    change.insertNodeByKey(parent.key, index + 1, block, { normalize })\n  } else if (range.isAtStartOf(startBlock)) {\n    change.insertNodeByKey(parent.key, index, block, { normalize })\n  } else if (range.isAtEndOf(startBlock)) {\n    change.insertNodeByKey(parent.key, index + 1, block, { normalize })\n  } else {\n    change.splitDescendantsByKey(startBlock.key, startKey, startOffset, {\n      normalize: false,\n    })\n    change.insertNodeByKey(parent.key, index + 1, block, { normalize })\n  }\n\n  if (normalize) {\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Insert a `fragment` at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Document} fragment\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.insertFragmentAtRange = (change, range, fragment, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n\n  // If the range is expanded, delete it first.\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize: false })\n    if (change.value.document.getDescendant(range.startKey)) {\n      range = range.collapseToStart()\n    } else {\n      range = range.collapseTo(range.endKey, 0)\n    }\n  }\n\n  // If the fragment is empty, there's nothing to do after deleting.\n  if (!fragment.nodes.size) return\n\n  // Regenerate the keys for all of the fragments nodes, so that they're\n  // guaranteed not to collide with the existing keys in the document. Otherwise\n  // they will be rengerated automatically and we won't have an easy way to\n  // reference them.\n  fragment = fragment.mapDescendants(child => child.regenerateKey())\n\n  // Calculate a few things...\n  const { startKey, startOffset } = range\n  const { value } = change\n  let { document } = value\n  let startText = document.getDescendant(startKey)\n  let startBlock = document.getClosestBlock(startText.key)\n  let startChild = startBlock.getFurthestAncestor(startText.key)\n  const isAtStart = range.isAtStartOf(startBlock)\n  const parent = document.getParent(startBlock.key)\n  const index = parent.nodes.indexOf(startBlock)\n  const blocks = fragment.getBlocks()\n  const firstChild = fragment.nodes.first()\n  const lastChild = fragment.nodes.last()\n  const firstBlock = blocks.first()\n  const lastBlock = blocks.last()\n\n  // If the fragment only contains a void block, use `insertBlock` instead.\n  if (firstBlock == lastBlock && firstBlock.isVoid) {\n    change.insertBlockAtRange(range, firstBlock, options)\n    return\n  }\n\n  // If the fragment starts or ends with single nested block, (e.g., table),\n  // do not merge this fragment with existing blocks.\n  if (fragment.hasBlocks(firstChild.key) || fragment.hasBlocks(lastChild.key)) {\n    fragment.nodes.reverse().forEach(node => {\n      change.insertBlockAtRange(range, node, options)\n    })\n    return\n  }\n\n  // If the first and last block aren't the same, we need to insert all of the\n  // nodes after the fragment's first block at the index.\n  if (firstBlock != lastBlock) {\n    const lonelyParent = fragment.getFurthest(\n      firstBlock.key,\n      p => p.nodes.size == 1\n    )\n    const lonelyChild = lonelyParent || firstBlock\n    const startIndex = parent.nodes.indexOf(startBlock)\n    fragment = fragment.removeDescendant(lonelyChild.key)\n\n    fragment.nodes.forEach((node, i) => {\n      const newIndex = startIndex + i + 1\n      change.insertNodeByKey(parent.key, newIndex, node, { normalize: false })\n    })\n  }\n\n  // Check if we need to split the node.\n  if (startOffset != 0) {\n    change.splitDescendantsByKey(startChild.key, startKey, startOffset, {\n      normalize: false,\n    })\n  }\n\n  // Update our variables with the new value.\n  document = change.value.document\n  startText = document.getDescendant(startKey)\n  startBlock = document.getClosestBlock(startKey)\n  startChild = startBlock.getFurthestAncestor(startText.key)\n\n  // If the first and last block aren't the same, we need to move any of the\n  // starting block's children after the split into the last block of the\n  // fragment, which has already been inserted.\n  if (firstBlock != lastBlock) {\n    const nextChild = isAtStart\n      ? startChild\n      : startBlock.getNextSibling(startChild.key)\n    const nextNodes = nextChild\n      ? startBlock.nodes.skipUntil(n => n.key == nextChild.key)\n      : List()\n    const lastIndex = lastBlock.nodes.size\n\n    nextNodes.forEach((node, i) => {\n      const newIndex = lastIndex + i\n      change.moveNodeByKey(node.key, lastBlock.key, newIndex, {\n        normalize: false,\n      })\n    })\n  }\n\n  // If the starting block is empty, we replace it entirely with the first block\n  // of the fragment, since this leads to a more expected behavior for the user.\n  if (startBlock.isEmpty) {\n    change.removeNodeByKey(startBlock.key, { normalize: false })\n    change.insertNodeByKey(parent.key, index, firstBlock, { normalize: false })\n  } else {\n    // Otherwise, we maintain the starting block, and insert all of the first\n    // block's inline nodes into it at the split point.\n    const inlineChild = startBlock.getFurthestAncestor(startText.key)\n    const inlineIndex = startBlock.nodes.indexOf(inlineChild)\n\n    firstBlock.nodes.forEach((inline, i) => {\n      const o = startOffset == 0 ? 0 : 1\n      const newIndex = inlineIndex + i + o\n      change.insertNodeByKey(startBlock.key, newIndex, inline, {\n        normalize: false,\n      })\n    })\n  }\n\n  // Normalize if requested.\n  if (normalize) {\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Insert an `inline` node at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Inline|String|Object} inline\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.insertInlineAtRange = (change, range, inline, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  inline = Inline.create(inline)\n\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize: false })\n    range = range.collapseToStart()\n  }\n\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset } = range\n  const parent = document.getParent(startKey)\n  const startText = document.assertDescendant(startKey)\n  const index = parent.nodes.indexOf(startText)\n\n  if (parent.isVoid) return\n\n  change.splitNodeByKey(startKey, startOffset, { normalize: false })\n  change.insertNodeByKey(parent.key, index + 1, inline, { normalize: false })\n\n  if (normalize) {\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Insert `text` at a `range`, with optional `marks`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.insertTextAtRange = (change, range, text, marks, options = {}) => {\n  let { normalize } = options\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset } = range\n  let key = startKey\n  let offset = startOffset\n  const parent = document.getParent(startKey)\n\n  if (parent.isVoid) return\n\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize: false })\n\n    // Update range start after delete\n    if (change.value.startKey !== key) {\n      key = change.value.startKey\n      offset = change.value.startOffset\n    }\n  }\n\n  // PERF: Unless specified, don't normalize if only inserting text.\n  if (normalize === undefined) {\n    normalize = range.isExpanded && marks.size !== 0\n  }\n  change.insertTextByKey(key, offset, text, marks, { normalize: false })\n\n  if (normalize) {\n    // normalize in the narrowest existing block that originally contains startKey and endKey\n    const commonAncestor = document.getCommonAncestor(startKey, range.endKey)\n    const ancestors = document\n      .getAncestors(commonAncestor.key)\n      .push(commonAncestor)\n    const normalizeAncestor = ancestors.findLast(n =>\n      change.value.document.getDescendant(n.key)\n    )\n    // it is possible that normalizeAncestor doesn't return any node\n    // on that case fallback to startKey to be normalized\n    const normalizeKey = normalizeAncestor ? normalizeAncestor.key : startKey\n    change.normalizeNodeByKey(normalizeKey)\n  }\n}\n\n/**\n * Remove an existing `mark` to the characters at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Mark|String} mark (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.removeMarkAtRange = (change, range, mark, options = {}) => {\n  if (range.isCollapsed) return\n\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const texts = document.getTextsAtRange(range)\n  const { startKey, startOffset, endKey, endOffset } = range\n\n  texts.forEach(node => {\n    const { key } = node\n    let index = 0\n    let length = node.text.length\n\n    if (key == startKey) index = startOffset\n    if (key == endKey) length = endOffset\n    if (key == startKey && key == endKey) length = endOffset - startOffset\n\n    change.removeMarkByKey(key, index, length, mark, { normalize })\n  })\n}\n\n/**\n * Set the `properties` of block nodes in a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object|String} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.setBlocksAtRange = (change, range, properties, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const blocks = document.getBlocksAtRange(range)\n\n  const { startKey, startOffset, endKey, endOffset, isCollapsed } = range\n  const isStartVoid = document.hasVoidParent(startKey)\n  const startBlock = document.getClosestBlock(startKey)\n  const endBlock = document.getClosestBlock(endKey)\n\n  // Check if we have a \"hanging\" selection case where the even though the\n  // selection extends into the start of the end node, we actually want to\n  // ignore that for UX reasons.\n  const isHanging =\n    isCollapsed == false &&\n    startOffset == 0 &&\n    endOffset == 0 &&\n    isStartVoid == false &&\n    startKey == startBlock.getFirstText().key &&\n    endKey == endBlock.getFirstText().key\n\n  // If it's a hanging selection, ignore the last block.\n  const sets = isHanging ? blocks.slice(0, -1) : blocks\n\n  sets.forEach(block => {\n    change.setNodeByKey(block.key, properties, { normalize })\n  })\n}\n\nChanges.setBlockAtRange = (...args) => {\n  logger.deprecate(\n    'slate@0.33.0',\n    'The `setBlockAtRange` method of Slate changes has been renamed to `setBlocksAtRange`.'\n  )\n  Changes.setBlocksAtRange(...args)\n}\n\n/**\n * Set the `properties` of inline nodes in a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object|String} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.setInlinesAtRange = (change, range, properties, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const inlines = document.getInlinesAtRange(range)\n\n  inlines.forEach(inline => {\n    change.setNodeByKey(inline.key, properties, { normalize })\n  })\n}\n\nChanges.setInlineAtRange = (...args) => {\n  logger.deprecate(\n    'slate@0.33.0',\n    'The `setInlineAtRange` method of Slate changes has been renamed to `setInlinesAtRange`.'\n  )\n  Changes.setInlinesAtRange(...args)\n}\n\n/**\n * Split the block nodes at a `range`, to optional `height`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Number} height (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.splitBlockAtRange = (change, range, height = 1, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n\n  const { startKey, startOffset, endOffset, endKey } = range\n  const { value } = change\n  const { document } = value\n  let node = document.assertDescendant(startKey)\n  let parent = document.getClosestBlock(node.key)\n  let h = 0\n\n  while (parent && parent.object == 'block' && h < height) {\n    node = parent\n    parent = document.getClosestBlock(parent.key)\n    h++\n  }\n\n  change.splitDescendantsByKey(node.key, startKey, startOffset, {\n    normalize: normalize && range.isCollapsed,\n  })\n\n  if (range.isExpanded) {\n    if (range.isBackward) range = range.flip()\n    const nextBlock = change.value.document.getNextBlock(node.key)\n    range = range.moveAnchorToStartOf(nextBlock)\n    if (startKey === endKey) {\n      range = range.moveFocusTo(range.anchorKey, endOffset - startOffset)\n    }\n    change.deleteAtRange(range, { normalize })\n  }\n}\n\n/**\n * Split the inline nodes at a `range`, to optional `height`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Number} height (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.splitInlineAtRange = (\n  change,\n  range,\n  height = Infinity,\n  options = {}\n) => {\n  const normalize = change.getFlag('normalize', options)\n\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize })\n    range = range.collapseToStart()\n  }\n\n  const { startKey, startOffset } = range\n  const { value } = change\n  const { document } = value\n  let node = document.assertDescendant(startKey)\n  let parent = document.getClosestInline(node.key)\n  let h = 0\n\n  while (parent && parent.object == 'inline' && h < height) {\n    node = parent\n    parent = document.getClosestInline(parent.key)\n    h++\n  }\n\n  change.splitDescendantsByKey(node.key, startKey, startOffset, { normalize })\n}\n\n/**\n * Add or remove a `mark` from the characters at `range`, depending on whether\n * it's already there.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Mixed} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.toggleMarkAtRange = (change, range, mark, options = {}) => {\n  if (range.isCollapsed) return\n\n  mark = Mark.create(mark)\n\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const marks = document.getActiveMarksAtRange(range)\n  const exists = marks.some(m => m.equals(mark))\n\n  if (exists) {\n    change.removeMarkAtRange(range, mark, { normalize })\n  } else {\n    change.addMarkAtRange(range, mark, { normalize })\n  }\n}\n\n/**\n * Unwrap all of the block nodes in a `range` from a block with `properties`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {String|Object} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.unwrapBlockAtRange = (change, range, properties, options = {}) => {\n  properties = Node.createProperties(properties)\n\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  let { document } = value\n  const blocks = document.getBlocksAtRange(range)\n  const wrappers = blocks\n    .map(block => {\n      return document.getClosest(block.key, parent => {\n        if (parent.object != 'block') return false\n        if (properties.type != null && parent.type != properties.type)\n          return false\n        if (properties.isVoid != null && parent.isVoid != properties.isVoid)\n          return false\n        if (properties.data != null && !parent.data.isSuperset(properties.data))\n          return false\n        return true\n      })\n    })\n    .filter(exists => exists)\n    .toOrderedSet()\n    .toList()\n\n  wrappers.forEach(block => {\n    const first = block.nodes.first()\n    const last = block.nodes.last()\n    const parent = document.getParent(block.key)\n    const index = parent.nodes.indexOf(block)\n\n    const children = block.nodes.filter(child => {\n      return blocks.some(b => child == b || child.hasDescendant(b.key))\n    })\n\n    const firstMatch = children.first()\n    const lastMatch = children.last()\n\n    if (first == firstMatch && last == lastMatch) {\n      block.nodes.forEach((child, i) => {\n        change.moveNodeByKey(child.key, parent.key, index + i, {\n          normalize: false,\n        })\n      })\n\n      change.removeNodeByKey(block.key, { normalize: false })\n    } else if (last == lastMatch) {\n      block.nodes.skipUntil(n => n == firstMatch).forEach((child, i) => {\n        change.moveNodeByKey(child.key, parent.key, index + 1 + i, {\n          normalize: false,\n        })\n      })\n    } else if (first == firstMatch) {\n      block.nodes\n        .takeUntil(n => n == lastMatch)\n        .push(lastMatch)\n        .forEach((child, i) => {\n          change.moveNodeByKey(child.key, parent.key, index + i, {\n            normalize: false,\n          })\n        })\n    } else {\n      const firstText = firstMatch.getFirstText()\n      change.splitDescendantsByKey(block.key, firstText.key, 0, {\n        normalize: false,\n      })\n      document = change.value.document\n\n      children.forEach((child, i) => {\n        if (i == 0) {\n          const extra = child\n          child = document.getNextBlock(child.key)\n          change.removeNodeByKey(extra.key, { normalize: false })\n        }\n\n        change.moveNodeByKey(child.key, parent.key, index + 1 + i, {\n          normalize: false,\n        })\n      })\n    }\n  })\n\n  // TODO: optmize to only normalize the right block\n  if (normalize) {\n    change.normalizeDocument()\n  }\n}\n\n/**\n * Unwrap the inline nodes in a `range` from an inline with `properties`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {String|Object} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.unwrapInlineAtRange = (change, range, properties, options = {}) => {\n  properties = Node.createProperties(properties)\n\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const texts = document.getTextsAtRange(range)\n  const inlines = texts\n    .map(text => {\n      return document.getClosest(text.key, parent => {\n        if (parent.object != 'inline') return false\n        if (properties.type != null && parent.type != properties.type)\n          return false\n        if (properties.isVoid != null && parent.isVoid != properties.isVoid)\n          return false\n        if (properties.data != null && !parent.data.isSuperset(properties.data))\n          return false\n        return true\n      })\n    })\n    .filter(exists => exists)\n    .toOrderedSet()\n    .toList()\n\n  inlines.forEach(inline => {\n    const parent = change.value.document.getParent(inline.key)\n    const index = parent.nodes.indexOf(inline)\n\n    inline.nodes.forEach((child, i) => {\n      change.moveNodeByKey(child.key, parent.key, index + i, {\n        normalize: false,\n      })\n    })\n  })\n\n  // TODO: optmize to only normalize the right block\n  if (normalize) {\n    change.normalizeDocument()\n  }\n}\n\n/**\n * Wrap all of the blocks in a `range` in a new `block`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Block|Object|String} block\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.wrapBlockAtRange = (change, range, block, options = {}) => {\n  block = Block.create(block)\n  block = block.set('nodes', block.nodes.clear())\n\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n\n  const blocks = document.getBlocksAtRange(range)\n  const firstblock = blocks.first()\n  const lastblock = blocks.last()\n  let parent, siblings, index\n\n  // If there is only one block in the selection then we know the parent and\n  // siblings.\n  if (blocks.length === 1) {\n    parent = document.getParent(firstblock.key)\n    siblings = blocks\n  } else {\n    // Determine closest shared parent to all blocks in selection.\n    parent = document.getClosest(firstblock.key, p1 => {\n      return !!document.getClosest(lastblock.key, p2 => p1 == p2)\n    })\n  }\n\n  // If no shared parent could be found then the parent is the document.\n  if (parent == null) parent = document\n\n  // Create a list of direct children siblings of parent that fall in the\n  // selection.\n  if (siblings == null) {\n    const indexes = parent.nodes.reduce((ind, node, i) => {\n      if (node == firstblock || node.hasDescendant(firstblock.key)) ind[0] = i\n      if (node == lastblock || node.hasDescendant(lastblock.key)) ind[1] = i\n      return ind\n    }, [])\n\n    index = indexes[0]\n    siblings = parent.nodes.slice(indexes[0], indexes[1] + 1)\n  }\n\n  // Get the index to place the new wrapped node at.\n  if (index == null) {\n    index = parent.nodes.indexOf(siblings.first())\n  }\n\n  // Inject the new block node into the parent.\n  change.insertNodeByKey(parent.key, index, block, { normalize: false })\n\n  // Move the sibling nodes into the new block node.\n  siblings.forEach((node, i) => {\n    change.moveNodeByKey(node.key, block.key, i, { normalize: false })\n  })\n\n  if (normalize) {\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Wrap the text and inlines in a `range` in a new `inline`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Inline|Object|String} inline\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.wrapInlineAtRange = (change, range, inline, options = {}) => {\n  const { value } = change\n  let { document } = value\n  const normalize = change.getFlag('normalize', options)\n  const { startKey, startOffset, endKey, endOffset } = range\n\n  if (range.isCollapsed) {\n    // Wrapping an inline void\n    const inlineParent = document.getClosestInline(startKey)\n    if (!inlineParent.isVoid) {\n      return\n    }\n\n    return change.wrapInlineByKey(inlineParent.key, inline, options)\n  }\n\n  inline = Inline.create(inline)\n  inline = inline.set('nodes', inline.nodes.clear())\n\n  const blocks = document.getBlocksAtRange(range)\n  let startBlock = document.getClosestBlock(startKey)\n  let endBlock = document.getClosestBlock(endKey)\n  let startChild = startBlock.getFurthestAncestor(startKey)\n  let endChild = endBlock.getFurthestAncestor(endKey)\n\n  change.splitDescendantsByKey(endChild.key, endKey, endOffset, {\n    normalize: false,\n  })\n  change.splitDescendantsByKey(startChild.key, startKey, startOffset, {\n    normalize: false,\n  })\n\n  document = change.value.document\n  startBlock = document.getDescendant(startBlock.key)\n  endBlock = document.getDescendant(endBlock.key)\n  startChild = startBlock.getFurthestAncestor(startKey)\n  endChild = endBlock.getFurthestAncestor(endKey)\n  const startIndex = startBlock.nodes.indexOf(startChild)\n  const endIndex = endBlock.nodes.indexOf(endChild)\n\n  if (startBlock == endBlock) {\n    document = change.value.document\n    startBlock = document.getClosestBlock(startKey)\n    startChild = startBlock.getFurthestAncestor(startKey)\n\n    const startInner = document.getNextSibling(startChild.key)\n    const startInnerIndex = startBlock.nodes.indexOf(startInner)\n    const endInner =\n      startKey == endKey ? startInner : startBlock.getFurthestAncestor(endKey)\n    const inlines = startBlock.nodes\n      .skipUntil(n => n == startInner)\n      .takeUntil(n => n == endInner)\n      .push(endInner)\n\n    const node = inline.regenerateKey()\n\n    change.insertNodeByKey(startBlock.key, startInnerIndex, node, {\n      normalize: false,\n    })\n\n    inlines.forEach((child, i) => {\n      change.moveNodeByKey(child.key, node.key, i, { normalize: false })\n    })\n\n    if (normalize) {\n      change.normalizeNodeByKey(startBlock.key)\n    }\n  } else {\n    const startInlines = startBlock.nodes.slice(startIndex + 1)\n    const endInlines = endBlock.nodes.slice(0, endIndex + 1)\n    const startNode = inline.regenerateKey()\n    const endNode = inline.regenerateKey()\n\n    change.insertNodeByKey(startBlock.key, startIndex + 1, startNode, {\n      normalize: false,\n    })\n    change.insertNodeByKey(endBlock.key, endIndex, endNode, {\n      normalize: false,\n    })\n\n    startInlines.forEach((child, i) => {\n      change.moveNodeByKey(child.key, startNode.key, i, { normalize: false })\n    })\n\n    endInlines.forEach((child, i) => {\n      change.moveNodeByKey(child.key, endNode.key, i, { normalize: false })\n    })\n\n    if (normalize) {\n      change.normalizeNodeByKey(startBlock.key).normalizeNodeByKey(endBlock.key)\n    }\n\n    blocks.slice(1, -1).forEach(block => {\n      const node = inline.regenerateKey()\n      change.insertNodeByKey(block.key, 0, node, { normalize: false })\n\n      block.nodes.forEach((child, i) => {\n        change.moveNodeByKey(child.key, node.key, i, { normalize: false })\n      })\n\n      if (normalize) {\n        change.normalizeNodeByKey(block.key)\n      }\n    })\n  }\n}\n\n/**\n * Wrap the text in a `range` in a prefix/suffix.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {String} prefix\n * @param {String} suffix (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.wrapTextAtRange = (\n  change,\n  range,\n  prefix,\n  suffix = prefix,\n  options = {}\n) => {\n  const normalize = change.getFlag('normalize', options)\n  const { startKey, endKey } = range\n  const start = range.collapseToStart()\n  let end = range.collapseToEnd()\n\n  if (startKey == endKey) {\n    end = end.move(prefix.length)\n  }\n\n  change.insertTextAtRange(start, prefix, [], { normalize })\n  change.insertTextAtRange(end, suffix, [], { normalize })\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Changes\n","import Block from '../models/block'\nimport Inline from '../models/inline'\nimport Mark from '../models/mark'\nimport Node from '../models/node'\nimport Range from '../models/range'\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nconst Changes = {}\n\n/**\n * Add mark to text at `offset` and `length` in node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Number} offset\n * @param {Number} length\n * @param {Mixed} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.addMarkByKey = (change, key, offset, length, mark, options = {}) => {\n  mark = Mark.create(mark)\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const path = document.getPath(key)\n  const node = document.getNode(key)\n  const leaves = node.getLeaves()\n\n  const operations = []\n  const bx = offset\n  const by = offset + length\n  let o = 0\n\n  leaves.forEach(leaf => {\n    const ax = o\n    const ay = ax + leaf.text.length\n\n    o += leaf.text.length\n\n    // If the leaf doesn't overlap with the operation, continue on.\n    if (ay < bx || by < ax) return\n\n    // If the leaf already has the mark, continue on.\n    if (leaf.marks.has(mark)) return\n\n    // Otherwise, determine which offset and characters overlap.\n    const start = Math.max(ax, bx)\n    const end = Math.min(ay, by)\n\n    operations.push({\n      type: 'add_mark',\n      value,\n      path,\n      offset: start,\n      length: end - start,\n      mark,\n    })\n  })\n\n  change.applyOperations(operations)\n\n  if (normalize) {\n    const parent = document.getParent(key)\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Insert a `fragment` at `index` in a node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Number} index\n * @param {Fragment} fragment\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.insertFragmentByKey = (change, key, index, fragment, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n\n  fragment.nodes.forEach((node, i) => {\n    change.insertNodeByKey(key, index + i, node)\n  })\n\n  if (normalize) {\n    change.normalizeNodeByKey(key)\n  }\n}\n\n/**\n * Insert a `node` at `index` in a node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Number} index\n * @param {Node} node\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.insertNodeByKey = (change, key, index, node, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const path = document.getPath(key)\n\n  change.applyOperation({\n    type: 'insert_node',\n    value,\n    path: [...path, index],\n    node,\n  })\n\n  if (normalize) {\n    change.normalizeNodeByKey(key)\n  }\n}\n\n/**\n * Insert `text` at `offset` in node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Number} offset\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.insertTextByKey = (change, key, offset, text, marks, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n\n  const { value } = change\n  const { document } = value\n  const path = document.getPath(key)\n  const node = document.getNode(key)\n  marks = marks || node.getMarksAtIndex(offset)\n\n  change.applyOperation({\n    type: 'insert_text',\n    value,\n    path,\n    offset,\n    text,\n    marks,\n  })\n\n  if (normalize) {\n    const parent = document.getParent(key)\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Merge a node by `key` with the previous node.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.mergeNodeByKey = (change, key, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const path = document.getPath(key)\n  const original = document.getDescendant(key)\n  const previous = document.getPreviousSibling(key)\n\n  if (!previous) {\n    throw new Error(`Unable to merge node with key \"${key}\", no previous key.`)\n  }\n\n  const position =\n    previous.object == 'text' ? previous.text.length : previous.nodes.size\n\n  change.applyOperation({\n    type: 'merge_node',\n    value,\n    path,\n    position,\n    // for undos to succeed we only need the type and data because\n    // these are the only properties that get changed in the merge operation\n    properties: {\n      type: original.type,\n      data: original.data,\n    },\n    target: null,\n  })\n\n  if (normalize) {\n    const parent = document.getParent(key)\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Move a node by `key` to a new parent by `newKey` and `index`.\n * `newKey` is the key of the container (it can be the document itself)\n *\n * @param {Change} change\n * @param {String} key\n * @param {String} newKey\n * @param {Number} index\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.moveNodeByKey = (change, key, newKey, newIndex, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const path = document.getPath(key)\n  const newPath = document.getPath(newKey)\n\n  change.applyOperation({\n    type: 'move_node',\n    value,\n    path,\n    newPath: [...newPath, newIndex],\n  })\n\n  if (normalize) {\n    const parent = document.getCommonAncestor(key, newKey)\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Remove mark from text at `offset` and `length` in node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Number} offset\n * @param {Number} length\n * @param {Mark} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.removeMarkByKey = (change, key, offset, length, mark, options = {}) => {\n  mark = Mark.create(mark)\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const path = document.getPath(key)\n  const node = document.getNode(key)\n  const leaves = node.getLeaves()\n\n  const operations = []\n  const bx = offset\n  const by = offset + length\n  let o = 0\n\n  leaves.forEach(leaf => {\n    const ax = o\n    const ay = ax + leaf.text.length\n\n    o += leaf.text.length\n\n    // If the leaf doesn't overlap with the operation, continue on.\n    if (ay < bx || by < ax) return\n\n    // If the leaf already has the mark, continue on.\n    if (!leaf.marks.has(mark)) return\n\n    // Otherwise, determine which offset and characters overlap.\n    const start = Math.max(ax, bx)\n    const end = Math.min(ay, by)\n\n    operations.push({\n      type: 'remove_mark',\n      value,\n      path,\n      offset: start,\n      length: end - start,\n      mark,\n    })\n  })\n\n  change.applyOperations(operations)\n\n  if (normalize) {\n    const parent = document.getParent(key)\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Remove all `marks` from node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.removeAllMarksByKey = (change, key, options = {}) => {\n  const { state } = change\n  const { document } = state\n  const node = document.getNode(key)\n  const texts = node.object === 'text' ? [node] : node.getTextsAsArray()\n\n  texts.forEach(text => {\n    text.getMarksAsArray().forEach(mark => {\n      change.removeMarkByKey(text.key, 0, text.text.length, mark, options)\n    })\n  })\n}\n\n/**\n * Remove a node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.removeNodeByKey = (change, key, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const path = document.getPath(key)\n  const node = document.getNode(key)\n\n  change.applyOperation({\n    type: 'remove_node',\n    value,\n    path,\n    node,\n  })\n\n  if (normalize) {\n    const parent = document.getParent(key)\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Insert `text` at `offset` in node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.setTextByKey = (change, key, text, marks, options = {}) => {\n  const textNode = change.value.document.getDescendant(key)\n  change.replaceTextByKey(key, 0, textNode.text.length, text, marks, options)\n}\n\n/**\n * Replace A Length of Text with another string or text\n * @param {Change} change\n * @param {String} key\n * @param {Number} offset\n * @param {Number} length\n * @param {string} text\n * @param {Set<Mark>} marks (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n *\n */\n\nChanges.replaceTextByKey = (\n  change,\n  key,\n  offset,\n  length,\n  text,\n  marks,\n  options\n) => {\n  const { document } = change.value\n  const textNode = document.getDescendant(key)\n  if (length + offset > textNode.text.length) {\n    length = textNode.text.length - offset\n  }\n  const range = Range.create({\n    anchorKey: key,\n    focusKey: key,\n    anchorOffset: offset,\n    focusOffset: offset + length,\n  })\n  let activeMarks = document.getActiveMarksAtRange(range)\n\n  change.removeTextByKey(key, offset, length, { normalize: false })\n  if (!marks) {\n    // Do not use mark at index when marks and activeMarks are both empty\n    marks = activeMarks ? activeMarks : []\n  } else if (activeMarks) {\n    // Do not use `has` because we may want to reset marks like font-size with an updated data;\n    activeMarks = activeMarks.filter(\n      activeMark => !marks.find(m => activeMark.type === m.type)\n    )\n    marks = activeMarks.merge(marks)\n  }\n  change.insertTextByKey(key, offset, text, marks, options)\n}\n\n/**\n * Remove text at `offset` and `length` in node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Number} offset\n * @param {Number} length\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.removeTextByKey = (change, key, offset, length, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const path = document.getPath(key)\n  const node = document.getNode(key)\n  const leaves = node.getLeaves()\n  const { text } = node\n\n  const removals = []\n  const bx = offset\n  const by = offset + length\n  let o = 0\n\n  leaves.forEach(leaf => {\n    const ax = o\n    const ay = ax + leaf.text.length\n\n    o += leaf.text.length\n\n    // If the leaf doesn't overlap with the removal, continue on.\n    if (ay < bx || by < ax) return\n\n    // Otherwise, determine which offset and characters overlap.\n    const start = Math.max(ax, bx)\n    const end = Math.min(ay, by)\n    const string = text.slice(start, end)\n\n    removals.push({\n      type: 'remove_text',\n      value,\n      path,\n      offset: start,\n      text: string,\n      marks: leaf.marks,\n    })\n  })\n\n  // Apply in reverse order, so subsequent removals don't impact previous ones.\n  change.applyOperations(removals.reverse())\n\n  if (normalize) {\n    const block = document.getClosestBlock(key)\n    change.normalizeNodeByKey(block.key)\n  }\n}\n\n/**\n`* Replace a `node` with another `node`\n *\n * @param {Change} change\n * @param {String} key\n * @param {Object|Node} node\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.replaceNodeByKey = (change, key, newNode, options = {}) => {\n  newNode = Node.create(newNode)\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const node = document.getNode(key)\n  const parent = document.getParent(key)\n  const index = parent.nodes.indexOf(node)\n  change.removeNodeByKey(key, { normalize: false })\n  change.insertNodeByKey(parent.key, index, newNode, { normalize: false })\n  if (normalize) {\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Set `properties` on mark on text at `offset` and `length` in node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Number} offset\n * @param {Number} length\n * @param {Mark} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.setMarkByKey = (\n  change,\n  key,\n  offset,\n  length,\n  mark,\n  properties,\n  options = {}\n) => {\n  mark = Mark.create(mark)\n  properties = Mark.createProperties(properties)\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const path = document.getPath(key)\n\n  change.applyOperation({\n    type: 'set_mark',\n    value,\n    path,\n    offset,\n    length,\n    mark,\n    properties,\n  })\n\n  if (normalize) {\n    const parent = document.getParent(key)\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Set `properties` on a node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Object|String} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.setNodeByKey = (change, key, properties, options = {}) => {\n  properties = Node.createProperties(properties)\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const path = document.getPath(key)\n  const node = document.getNode(key)\n\n  change.applyOperation({\n    type: 'set_node',\n    value,\n    path,\n    node,\n    properties,\n  })\n\n  if (normalize) {\n    change.normalizeNodeByKey(node.key)\n  }\n}\n\n/**\n * Split a node by `key` at `position`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Number} position\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.splitNodeByKey = (change, key, position, options = {}) => {\n  const { normalize = true, target = null } = options\n  const { value } = change\n  const { document } = value\n  const path = document.getPath(key)\n  const node = document.getDescendantAtPath(path)\n\n  change.applyOperation({\n    type: 'split_node',\n    value,\n    path,\n    position,\n    properties: {\n      type: node.type,\n      data: node.data,\n    },\n    target,\n  })\n\n  if (normalize) {\n    const parent = document.getParent(key)\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Split a node deeply down the tree by `key`, `textKey` and `textOffset`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Number} position\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.splitDescendantsByKey = (\n  change,\n  key,\n  textKey,\n  textOffset,\n  options = {}\n) => {\n  if (key == textKey) {\n    change.splitNodeByKey(textKey, textOffset, options)\n    return\n  }\n\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n\n  const text = document.getNode(textKey)\n  const ancestors = document.getAncestors(textKey)\n  const nodes = ancestors\n    .skipUntil(a => a.key == key)\n    .reverse()\n    .unshift(text)\n  let previous\n  let index\n\n  nodes.forEach(node => {\n    const prevIndex = index == null ? null : index\n    index = previous ? node.nodes.indexOf(previous) + 1 : textOffset\n    previous = node\n    change.splitNodeByKey(node.key, index, {\n      normalize: false,\n      target: prevIndex,\n    })\n  })\n\n  if (normalize) {\n    const parent = document.getParent(key)\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Unwrap content from an inline parent with `properties`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Object|String} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.unwrapInlineByKey = (change, key, properties, options) => {\n  const { value } = change\n  const { document, selection } = value\n  const node = document.assertDescendant(key)\n  const first = node.getFirstText()\n  const last = node.getLastText()\n  const range = selection.moveToRangeOf(first, last)\n  change.unwrapInlineAtRange(range, properties, options)\n}\n\n/**\n * Unwrap content from a block parent with `properties`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Object|String} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.unwrapBlockByKey = (change, key, properties, options) => {\n  const { value } = change\n  const { document, selection } = value\n  const node = document.assertDescendant(key)\n  const first = node.getFirstText()\n  const last = node.getLastText()\n  const range = selection.moveToRangeOf(first, last)\n  change.unwrapBlockAtRange(range, properties, options)\n}\n\n/**\n * Unwrap a single node from its parent.\n *\n * If the node is surrounded with siblings, its parent will be\n * split. If the node is the only child, the parent is removed, and\n * simply replaced by the node itself.  Cannot unwrap a root node.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.unwrapNodeByKey = (change, key, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const parent = document.getParent(key)\n  const node = parent.getChild(key)\n\n  const index = parent.nodes.indexOf(node)\n  const isFirst = index === 0\n  const isLast = index === parent.nodes.size - 1\n\n  const parentParent = document.getParent(parent.key)\n  const parentIndex = parentParent.nodes.indexOf(parent)\n\n  if (parent.nodes.size === 1) {\n    change.moveNodeByKey(key, parentParent.key, parentIndex, {\n      normalize: false,\n    })\n    change.removeNodeByKey(parent.key, options)\n  } else if (isFirst) {\n    // Just move the node before its parent.\n    change.moveNodeByKey(key, parentParent.key, parentIndex, options)\n  } else if (isLast) {\n    // Just move the node after its parent.\n    change.moveNodeByKey(key, parentParent.key, parentIndex + 1, options)\n  } else {\n    // Split the parent.\n    change.splitNodeByKey(parent.key, index, { normalize: false })\n\n    // Extract the node in between the splitted parent.\n    change.moveNodeByKey(key, parentParent.key, parentIndex + 1, {\n      normalize: false,\n    })\n\n    if (normalize) {\n      change.normalizeNodeByKey(parentParent.key)\n    }\n  }\n}\n\n/**\n * Wrap a node in a block with `properties`.\n *\n * @param {Change} change\n * @param {String} key The node to wrap\n * @param {Block|Object|String} block The wrapping block (its children are discarded)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.wrapBlockByKey = (change, key, block, options) => {\n  block = Block.create(block)\n  block = block.set('nodes', block.nodes.clear())\n\n  const { document } = change.value\n  const node = document.assertDescendant(key)\n  const parent = document.getParent(node.key)\n  const index = parent.nodes.indexOf(node)\n\n  change.insertNodeByKey(parent.key, index, block, { normalize: false })\n  change.moveNodeByKey(node.key, block.key, 0, options)\n}\n\n/**\n * Wrap a node in an inline with `properties`.\n *\n * @param {Change} change\n * @param {String} key The node to wrap\n * @param {Block|Object|String} inline The wrapping inline (its children are discarded)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.wrapInlineByKey = (change, key, inline, options) => {\n  inline = Inline.create(inline)\n  inline = inline.set('nodes', inline.nodes.clear())\n\n  const { document } = change.value\n  const node = document.assertDescendant(key)\n  const parent = document.getParent(node.key)\n  const index = parent.nodes.indexOf(node)\n\n  change.insertNodeByKey(parent.key, index, inline, { normalize: false })\n  change.moveNodeByKey(node.key, inline.key, 0, options)\n}\n\n/**\n * Wrap a node by `key` with `parent`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Node|Object} parent\n * @param {Object} options\n */\n\nChanges.wrapNodeByKey = (change, key, parent) => {\n  parent = Node.create(parent)\n  parent = parent.set('nodes', parent.nodes.clear())\n\n  if (parent.object == 'block') {\n    change.wrapBlockByKey(key, parent)\n    return\n  }\n\n  if (parent.object == 'inline') {\n    change.wrapInlineByKey(key, parent)\n    return\n  }\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Changes\n","/**\n * Slate operation attributes.\n *\n * @type {Array}\n */\n\nconst OPERATION_ATTRIBUTES = {\n  add_mark: ['value', 'path', 'offset', 'length', 'mark'],\n  insert_node: ['value', 'path', 'node'],\n  insert_text: ['value', 'path', 'offset', 'text', 'marks'],\n  merge_node: ['value', 'path', 'position', 'properties', 'target'],\n  move_node: ['value', 'path', 'newPath'],\n  remove_mark: ['value', 'path', 'offset', 'length', 'mark'],\n  remove_node: ['value', 'path', 'node'],\n  remove_text: ['value', 'path', 'offset', 'text', 'marks'],\n  set_mark: ['value', 'path', 'offset', 'length', 'mark', 'properties'],\n  set_node: ['value', 'path', 'node', 'properties'],\n  set_selection: ['value', 'selection', 'properties'],\n  set_value: ['value', 'properties'],\n  split_node: ['value', 'path', 'position', 'properties', 'target'],\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default OPERATION_ATTRIBUTES\n","import Debug from 'debug'\nimport isEqual from 'lodash/isEqual'\nimport isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport { List, Record, Stack } from 'immutable'\n\nimport MODEL_TYPES, { isType } from '../constants/model-types'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:history')\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  redos: new Stack(),\n  undos: new Stack(),\n}\n\n/**\n * History.\n *\n * @type {History}\n */\n\nclass History extends Record(DEFAULTS) {\n  /**\n   * Create a new `History` with `attrs`.\n   *\n   * @param {Object|History} attrs\n   * @return {History}\n   */\n\n  static create(attrs = {}) {\n    if (History.isHistory(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return History.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`History.create\\` only accepts objects or histories, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `History` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {History}\n   */\n\n  static fromJSON(object) {\n    const { redos = [], undos = [] } = object\n\n    const history = new History({\n      redos: new Stack(redos),\n      undos: new Stack(undos),\n    })\n\n    return history\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = History.fromJSON\n\n  /**\n   * Check if `any` is a `History`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isHistory = isType.bind(null, 'HISTORY')\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'history'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Save an `operation` into the history.\n   *\n   * @param {Object} operation\n   * @param {Object} options\n   * @return {History}\n   */\n\n  save(operation, options = {}) {\n    let history = this\n    let { undos, redos } = history\n    let { merge, skip } = options\n    const prevBatch = undos.peek()\n    const prevOperation = prevBatch && prevBatch.last()\n\n    if (skip == null) {\n      skip = shouldSkip(operation, prevOperation)\n    }\n\n    if (skip) {\n      return history\n    }\n\n    if (merge == null) {\n      merge = shouldMerge(operation, prevOperation)\n    }\n\n    debug('save', { operation, merge })\n\n    // If the `merge` flag is true, add the operation to the previous batch.\n    if (merge && prevBatch) {\n      const batch = prevBatch.push(operation)\n      undos = undos.pop()\n      undos = undos.push(batch)\n    } else {\n      // Otherwise, create a new batch with the operation.\n      const batch = new List([operation])\n      undos = undos.push(batch)\n    }\n\n    // Constrain the history to 100 entries for memory's sake.\n    if (undos.size > 100) {\n      undos = undos.take(100)\n    }\n\n    // Clear the redos and update the history.\n    redos = redos.clear()\n    history = history.set('undos', undos).set('redos', redos)\n    return history\n  }\n\n  /**\n   * Return a JSON representation of the history.\n   *\n   * @return {Object}\n   */\n\n  toJSON() {\n    const object = {\n      object: this.object,\n      redos: this.redos.toJSON(),\n      undos: this.undos.toJSON(),\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS() {\n    return this.toJSON()\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nHistory.prototype[MODEL_TYPES.HISTORY] = true\n\n/**\n * Check whether to merge a new operation `o` into the previous operation `p`.\n *\n * @param {Object} o\n * @param {Object} p\n * @return {Boolean}\n */\n\nfunction shouldMerge(o, p) {\n  if (!p) return false\n\n  const merge =\n    (o.type == 'set_selection' && p.type == 'set_selection') ||\n    (o.type == 'insert_text' &&\n      p.type == 'insert_text' &&\n      o.offset == p.offset + p.text.length &&\n      isEqual(o.path, p.path)) ||\n    (o.type == 'remove_text' &&\n      p.type == 'remove_text' &&\n      o.offset + o.text.length == p.offset &&\n      isEqual(o.path, p.path))\n\n  return merge\n}\n\n/**\n * Check whether to skip a new operation `o`, given previous operation `p`.\n *\n * @param {Object} o\n * @param {Object} p\n * @return {Boolean}\n */\n\nfunction shouldSkip(o, p) {\n  if (!p) return false\n\n  const skip = o.type == 'set_selection' && p.type == 'set_selection'\n\n  return skip\n}\n\n/**\n * Export.\n *\n * @type {History}\n */\n\nexport default History\n","import { List } from 'immutable'\n\nimport Text from '../models/text'\n\n/**\n * Define the core schema rules, order-sensitive.\n *\n * @type {Array}\n */\n\nconst CORE_SCHEMA_RULES = [\n  /**\n   * Only allow block nodes in documents.\n   *\n   * @type {Object}\n   */\n\n  {\n    validateNode(node) {\n      if (node.object != 'document') return\n      const invalids = node.nodes.filter(n => n.object != 'block')\n      if (!invalids.size) return\n\n      return change => {\n        invalids.forEach(child => {\n          change.removeNodeByKey(child.key, { normalize: false })\n        })\n      }\n    },\n  },\n\n  /**\n   * Only allow block nodes or inline and text nodes in blocks.\n   *\n   * @type {Object}\n   */\n\n  {\n    validateNode(node) {\n      if (node.object != 'block') return\n      const first = node.nodes.first()\n      if (!first) return\n      const objects = first.object == 'block' ? ['block'] : ['inline', 'text']\n      const invalids = node.nodes.filter(n => !objects.includes(n.object))\n      if (!invalids.size) return\n\n      return change => {\n        invalids.forEach(child => {\n          change.removeNodeByKey(child.key, { normalize: false })\n        })\n      }\n    },\n  },\n\n  /**\n   * Only allow inline and text nodes in inlines.\n   *\n   * @type {Object}\n   */\n\n  {\n    validateNode(node) {\n      if (node.object != 'inline') return\n      const invalids = node.nodes.filter(\n        n => n.object != 'inline' && n.object != 'text'\n      )\n      if (!invalids.size) return\n\n      return change => {\n        invalids.forEach(child => {\n          change.removeNodeByKey(child.key, { normalize: false })\n        })\n      }\n    },\n  },\n\n  /**\n   * Ensure that block and inline nodes have at least one text child.\n   *\n   * @type {Object}\n   */\n\n  {\n    validateNode(node) {\n      if (node.object != 'block' && node.object != 'inline') return\n      if (node.nodes.size > 0) return\n\n      return change => {\n        const text = Text.create()\n        change.insertNodeByKey(node.key, 0, text, { normalize: false })\n      }\n    },\n  },\n\n  /**\n   * Ensure that inline non-void nodes are never empty.\n   *\n   * This rule is applied to all blocks and inlines, because when they contain an empty\n   * inline, we need to remove the empty inline from that parent node. If `validate`\n   * was to be memoized, it should be against the parent node, not the empty inline itself.\n   *\n   * @type {Object}\n   */\n\n  {\n    validateNode(node) {\n      if (node.object != 'inline' && node.object != 'block') return\n\n      const invalids = node.nodes.filter(\n        child => child.object === 'inline' && child.isEmpty\n      )\n\n      if (!invalids.size) return\n\n      return change => {\n        // If all of the block's nodes are invalid, insert an empty text node so\n        // that the selection will be preserved when they are all removed.\n        if (node.nodes.size == invalids.size) {\n          const text = Text.create()\n          change.insertNodeByKey(node.key, 1, text, { normalize: false })\n        }\n\n        invalids.forEach(child => {\n          change.removeNodeByKey(child.key, { normalize: false })\n        })\n      }\n    },\n  },\n\n  /**\n   * Ensure that inline void nodes are surrounded by text nodes, by adding extra\n   * blank text nodes if necessary.\n   *\n   * @type {Object}\n   */\n\n  {\n    validateNode(node) {\n      if (node.object != 'block' && node.object != 'inline') return\n\n      const invalids = node.nodes.reduce((list, child, index) => {\n        if (child.object !== 'inline') return list\n\n        const prev = index > 0 ? node.nodes.get(index - 1) : null\n        const next = node.nodes.get(index + 1)\n\n        // We don't test if \"prev\" is inline, since it has already been\n        // processed in the loop\n        const insertBefore = !prev\n        const insertAfter = !next || next.object == 'inline'\n\n        if (insertAfter || insertBefore) {\n          list = list.push({ insertAfter, insertBefore, index })\n        }\n\n        return list\n      }, new List())\n\n      if (!invalids.size) return\n\n      return change => {\n        // Shift for every text node inserted previously.\n        let shift = 0\n\n        invalids.forEach(({ index, insertAfter, insertBefore }) => {\n          if (insertBefore) {\n            change.insertNodeByKey(node.key, shift + index, Text.create(), {\n              normalize: false,\n            })\n            shift++\n          }\n\n          if (insertAfter) {\n            change.insertNodeByKey(node.key, shift + index + 1, Text.create(), {\n              normalize: false,\n            })\n            shift++\n          }\n        })\n      }\n    },\n  },\n\n  /**\n   * Merge adjacent text nodes.\n   *\n   * @type {Object}\n   */\n\n  {\n    validateNode(node) {\n      if (node.object != 'block' && node.object != 'inline') return\n\n      const invalids = node.nodes\n        .map((child, i) => {\n          const next = node.nodes.get(i + 1)\n          if (child.object != 'text') return\n          if (!next || next.object != 'text') return\n          return next\n        })\n        .filter(Boolean)\n\n      if (!invalids.size) return\n\n      return change => {\n        // Reverse the list to handle consecutive merges, since the earlier nodes\n        // will always exist after each merge.\n        invalids.reverse().forEach(n => {\n          change.mergeNodeByKey(n.key, { normalize: false })\n        })\n      }\n    },\n  },\n\n  /**\n   * Prevent extra empty text nodes, except when adjacent to inline void nodes.\n   *\n   * @type {Object}\n   */\n\n  {\n    validateNode(node) {\n      if (node.object != 'block' && node.object != 'inline') return\n      const { nodes } = node\n      if (nodes.size <= 1) return\n\n      const invalids = nodes.filter((desc, i) => {\n        if (desc.object != 'text') return\n        if (desc.text.length > 0) return\n\n        const prev = i > 0 ? nodes.get(i - 1) : null\n        const next = nodes.get(i + 1)\n\n        // If it's the first node, and the next is a void, preserve it.\n        if (!prev && next.object == 'inline') return\n\n        // It it's the last node, and the previous is an inline, preserve it.\n        if (!next && prev.object == 'inline') return\n\n        // If it's surrounded by inlines, preserve it.\n        if (next && prev && next.object == 'inline' && prev.object == 'inline')\n          return\n\n        // Otherwise, remove it.\n        return true\n      })\n\n      if (!invalids.size) return\n\n      return change => {\n        invalids.forEach(text => {\n          change.removeNodeByKey(text.key, { normalize: false })\n        })\n      }\n    },\n  },\n]\n\n/**\n * Export.\n *\n * @type {Array}\n */\n\nexport default CORE_SCHEMA_RULES\n","import logger from 'slate-dev-logger'\nimport { Record } from 'immutable'\n\nimport MODEL_TYPES from '../constants/model-types'\nimport memoize from '../utils/memoize'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  plugins: [],\n}\n\n/**\n * Stack.\n *\n * @type {Stack}\n */\n\nclass Stack extends Record(DEFAULTS) {\n  /**\n   * Constructor.\n   *\n   * @param {Object} attrs\n   */\n\n  static create(attrs = {}) {\n    const { plugins = [] } = attrs\n    const stack = new Stack({ plugins })\n    return stack\n  }\n\n  /**\n   * Check if `any` is a `Stack`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isStack(any) {\n    return !!(any && any[MODEL_TYPES.STACK])\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'stack'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Get all plugins with `property`.\n   *\n   * @param {String} property\n   * @return {Array}\n   */\n\n  getPluginsWith(property) {\n    return this.plugins.filter(plugin => plugin[property] != null)\n  }\n\n  /**\n   * Iterate the plugins with `property`, returning the first non-null value.\n   *\n   * @param {String} property\n   * @param {Any} ...args\n   */\n\n  find(property, ...args) {\n    const plugins = this.getPluginsWith(property)\n\n    for (const plugin of plugins) {\n      const ret = plugin[property](...args)\n      if (ret != null) return ret\n    }\n  }\n\n  /**\n   * Iterate the plugins with `property`, returning all the non-null values.\n   *\n   * @param {String} property\n   * @param {Any} ...args\n   * @return {Array}\n   */\n\n  map(property, ...args) {\n    const plugins = this.getPluginsWith(property)\n    const array = []\n\n    for (const plugin of plugins) {\n      const ret = plugin[property](...args)\n      if (ret != null) array.push(ret)\n    }\n\n    return array\n  }\n\n  /**\n   * Iterate the plugins with `property`, breaking on any a non-null values.\n   *\n   * @param {String} property\n   * @param {Any} ...args\n   */\n\n  run(property, ...args) {\n    const plugins = this.getPluginsWith(property)\n\n    for (const plugin of plugins) {\n      const ret = plugin[property](...args)\n      if (ret != null) return\n    }\n  }\n\n  /**\n   * Iterate the plugins with `property`, reducing to a set of React children.\n   *\n   * @param {String} property\n   * @param {Object} props\n   * @param {Any} ...args\n   */\n\n  render(property, props, ...args) {\n    const plugins = this.getPluginsWith(property)\n    return plugins.reduceRight((children, plugin) => {\n      if (!plugin[property]) return children\n      const ret = plugin[property](props, ...args)\n      if (ret == null) return children\n      props.children = ret\n      return ret\n    }, props.children === undefined ? null : props.children)\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nStack.prototype[MODEL_TYPES.STACK] = true\n\n/**\n * Memoize read methods.\n */\n\nmemoize(Stack.prototype, ['getPluginsWith'])\n\n/**\n * Export.\n *\n * @type {Stack}\n */\n\nexport default Stack\n","import Debug from 'debug'\nimport isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport mergeWith from 'lodash/mergeWith'\nimport { Record } from 'immutable'\n\nimport {\n  CHILD_OBJECT_INVALID,\n  CHILD_REQUIRED,\n  CHILD_TYPE_INVALID,\n  CHILD_UNKNOWN,\n  FIRST_CHILD_OBJECT_INVALID,\n  FIRST_CHILD_TYPE_INVALID,\n  LAST_CHILD_OBJECT_INVALID,\n  LAST_CHILD_TYPE_INVALID,\n  NODE_DATA_INVALID,\n  NODE_IS_VOID_INVALID,\n  NODE_MARK_INVALID,\n  NODE_TEXT_INVALID,\n  PARENT_INVALID,\n} from 'slate-schema-violations'\n\nimport CORE_SCHEMA_RULES from '../constants/core-schema-rules'\nimport MODEL_TYPES from '../constants/model-types'\nimport Stack from './stack'\nimport memoize from '../utils/memoize'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:schema')\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  stack: Stack.create(),\n  document: {},\n  blocks: {},\n  inlines: {},\n}\n\n/**\n * Schema.\n *\n * @type {Schema}\n */\n\nclass Schema extends Record(DEFAULTS) {\n  /**\n   * Create a new `Schema` with `attrs`.\n   *\n   * @param {Object|Schema} attrs\n   * @return {Schema}\n   */\n\n  static create(attrs = {}) {\n    if (Schema.isSchema(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Schema.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Schema.create\\` only accepts objects or schemas, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Schema` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Schema}\n   */\n\n  static fromJSON(object) {\n    if (Schema.isSchema(object)) {\n      return object\n    }\n\n    let { plugins } = object\n\n    if (object.rules) {\n      throw new Error(\n        'Schemas in Slate have changed! They are no longer accept a `rules` property.'\n      )\n    }\n\n    if (object.nodes) {\n      throw new Error(\n        'Schemas in Slate have changed! They are no longer accept a `nodes` property.'\n      )\n    }\n\n    if (!plugins) {\n      plugins = [{ schema: object }]\n    }\n\n    const schema = resolveSchema(plugins)\n    const stack = Stack.create({ plugins: [...CORE_SCHEMA_RULES, ...plugins] })\n    const ret = new Schema({ ...schema, stack })\n    return ret\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Schema.fromJSON\n\n  /**\n   * Check if `any` is a `Schema`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isSchema(any) {\n    return !!(any && any[MODEL_TYPES.SCHEMA])\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'schema'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Get the rule for an `object`.\n   *\n   * @param {Mixed} object\n   * @return {Object}\n   */\n\n  getRule(object) {\n    switch (object.object) {\n      case 'document':\n        return this.document\n      case 'block':\n        return this.blocks[object.type]\n      case 'inline':\n        return this.inlines[object.type]\n    }\n  }\n\n  /**\n   * Get a dictionary of the parent rule validations by child type.\n   *\n   * @return {Object|Null}\n   */\n\n  getParentRules() {\n    const { blocks, inlines } = this\n    const parents = {}\n\n    for (const key in blocks) {\n      const rule = blocks[key]\n      if (rule.parent == null) continue\n      parents[key] = rule\n    }\n\n    for (const key in inlines) {\n      const rule = inlines[key]\n      if (rule.parent == null) continue\n      parents[key] = rule\n    }\n\n    return Object.keys(parents).length == 0 ? null : parents\n  }\n\n  /**\n   * Fail validation by returning a normalizing change function.\n   *\n   * @param {String} violation\n   * @param {Object} context\n   * @return {Function}\n   */\n\n  fail(violation, context) {\n    return change => {\n      debug(`normalizing`, { violation, context })\n      const { rule } = context\n      const { size } = change.operations\n      if (rule.normalize) rule.normalize(change, violation, context)\n      if (change.operations.size > size) return\n      this.normalize(change, violation, context)\n    }\n  }\n\n  /**\n   * Normalize an invalid value with `violation` and `context`.\n   *\n   * @param {Change} change\n   * @param {String} violation\n   * @param {Mixed} context\n   */\n\n  normalize(change, violation, context) {\n    switch (violation) {\n      case CHILD_OBJECT_INVALID:\n      case CHILD_TYPE_INVALID:\n      case CHILD_UNKNOWN:\n      case FIRST_CHILD_OBJECT_INVALID:\n      case FIRST_CHILD_TYPE_INVALID:\n      case LAST_CHILD_OBJECT_INVALID:\n      case LAST_CHILD_TYPE_INVALID: {\n        const { child, node } = context\n        return child.object == 'text' &&\n          node.object == 'block' &&\n          node.nodes.size == 1\n          ? change.removeNodeByKey(node.key)\n          : change.removeNodeByKey(child.key)\n      }\n\n      case CHILD_REQUIRED:\n      case NODE_TEXT_INVALID:\n      case PARENT_INVALID: {\n        const { node } = context\n        return node.object == 'document'\n          ? node.nodes.forEach(child => change.removeNodeByKey(child.key))\n          : change.removeNodeByKey(node.key)\n      }\n\n      case NODE_DATA_INVALID: {\n        const { node, key } = context\n        return node.data.get(key) === undefined && node.object != 'document'\n          ? change.removeNodeByKey(node.key)\n          : change.setNodeByKey(node.key, { data: node.data.delete(key) })\n      }\n\n      case NODE_IS_VOID_INVALID: {\n        const { node } = context\n        return change.setNodeByKey(node.key, { isVoid: !node.isVoid })\n      }\n\n      case NODE_MARK_INVALID: {\n        const { node, mark } = context\n        return node\n          .getTexts()\n          .forEach(t => change.removeMarkByKey(t.key, 0, t.text.length, mark))\n      }\n    }\n  }\n\n  /**\n   * Validate a `node` with the schema, returning a function that will fix the\n   * invalid node, or void if the node is valid.\n   *\n   * @param {Node} node\n   * @return {Function|Void}\n   */\n\n  validateNode(node) {\n    const ret = this.stack.find('validateNode', node)\n    if (ret) return ret\n\n    if (node.object == 'text') return\n\n    const rule = this.getRule(node) || {}\n    const parents = this.getParentRules()\n    const ctx = { node, rule }\n\n    if (rule.isVoid != null) {\n      if (node.isVoid != rule.isVoid) {\n        return this.fail(NODE_IS_VOID_INVALID, ctx)\n      }\n    }\n\n    if (rule.data != null) {\n      for (const key in rule.data) {\n        const fn = rule.data[key]\n        const value = node.data.get(key)\n\n        if (!fn(value)) {\n          return this.fail(NODE_DATA_INVALID, { ...ctx, key, value })\n        }\n      }\n    }\n\n    if (rule.marks != null) {\n      const marks = node.getMarks().toArray()\n\n      for (const mark of marks) {\n        if (!rule.marks.some(def => def.type === mark.type)) {\n          return this.fail(NODE_MARK_INVALID, { ...ctx, mark })\n        }\n      }\n    }\n\n    if (rule.text != null) {\n      const { text } = node\n\n      if (!rule.text.test(text)) {\n        return this.fail(NODE_TEXT_INVALID, { ...ctx, text })\n      }\n    }\n\n    if (rule.first != null) {\n      const { objects, types } = rule.first\n      const child = node.nodes.first()\n\n      if (child && objects && !objects.includes(child.object)) {\n        return this.fail(FIRST_CHILD_OBJECT_INVALID, { ...ctx, child })\n      }\n\n      if (child && types && !types.includes(child.type)) {\n        return this.fail(FIRST_CHILD_TYPE_INVALID, { ...ctx, child })\n      }\n    }\n\n    if (rule.last != null) {\n      const { objects, types } = rule.last\n      const child = node.nodes.last()\n\n      if (child && objects && !objects.includes(child.object)) {\n        return this.fail(LAST_CHILD_OBJECT_INVALID, { ...ctx, child })\n      }\n\n      if (child && types && !types.includes(child.type)) {\n        return this.fail(LAST_CHILD_TYPE_INVALID, { ...ctx, child })\n      }\n    }\n\n    if (rule.nodes != null || parents != null) {\n      const children = node.nodes.toArray()\n      const defs = rule.nodes != null ? rule.nodes.slice() : []\n\n      let offset\n      let min\n      let index\n      let def\n      let max\n      let child\n\n      function nextDef() {\n        offset = offset == null ? null : 0\n        def = defs.shift()\n        min = def && (def.min == null ? 0 : def.min)\n        max = def && (def.max == null ? Infinity : def.max)\n        return !!def\n      }\n\n      function nextChild() {\n        index = index == null ? 0 : index + 1\n        offset = offset == null ? 0 : offset + 1\n        child = children[index]\n        if (max != null && offset == max) nextDef()\n        return !!child\n      }\n      function rewind() {\n        offset -= 1\n        index -= 1\n      }\n\n      if (rule.nodes != null) {\n        nextDef()\n      }\n\n      while (nextChild()) {\n        if (\n          parents != null &&\n          child.object != 'text' &&\n          child.type in parents\n        ) {\n          const r = parents[child.type]\n\n          // Refer to PARENT_INVALID documentation for the specification\n          const definedObjects = r.parent.objects != null\n          const definedTypes = r.parent.types != null\n\n          const allowedObject =\n            definedObjects && r.parent.objects.includes(node.object)\n          const allowedType = definedTypes && r.parent.types.includes(node.type)\n\n          const allowed =\n            (!definedObjects && !definedTypes) || allowedObject || allowedType\n\n          if (!allowed) {\n            return this.fail(PARENT_INVALID, {\n              node: child,\n              parent: node,\n              rule: r,\n            })\n          }\n        }\n\n        if (rule.nodes != null) {\n          if (!def) {\n            return this.fail(CHILD_UNKNOWN, { ...ctx, child, index })\n          }\n\n          if (def.objects != null && !def.objects.includes(child.object)) {\n            if (offset >= min && nextDef()) {\n              rewind()\n              continue\n            }\n            return this.fail(CHILD_OBJECT_INVALID, { ...ctx, child, index })\n          }\n\n          if (def.types != null && !def.types.includes(child.type)) {\n            if (offset >= min && nextDef()) {\n              rewind()\n              continue\n            }\n            return this.fail(CHILD_TYPE_INVALID, { ...ctx, child, index })\n          }\n        }\n      }\n\n      if (rule.nodes != null) {\n        while (min != null) {\n          if (offset < min) {\n            return this.fail(CHILD_REQUIRED, { ...ctx, index })\n          }\n\n          nextDef()\n        }\n      }\n    }\n  }\n\n  /**\n   * Return a JSON representation of the schema.\n   *\n   * @return {Object}\n   */\n\n  toJSON() {\n    const object = {\n      object: this.object,\n      document: this.document,\n      blocks: this.blocks,\n      inlines: this.inlines,\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS() {\n    return this.toJSON()\n  }\n}\n\n/**\n * Resolve a set of schema rules from an array of `plugins`.\n *\n * @param {Array} plugins\n * @return {Object}\n */\n\nfunction resolveSchema(plugins = []) {\n  const schema = {\n    document: {},\n    blocks: {},\n    inlines: {},\n  }\n\n  plugins\n    .slice()\n    .reverse()\n    .forEach(plugin => {\n      if (!plugin.schema) return\n\n      if (plugin.schema.rules) {\n        throw new Error(\n          'Schemas in Slate have changed! They are no longer accept a `rules` property.'\n        )\n      }\n\n      if (plugin.schema.nodes) {\n        throw new Error(\n          'Schemas in Slate have changed! They are no longer accept a `nodes` property.'\n        )\n      }\n\n      const { document = {}, blocks = {}, inlines = {} } = plugin.schema\n      const d = resolveDocumentRule(document)\n      const bs = {}\n      const is = {}\n\n      for (const key in blocks) {\n        bs[key] = resolveNodeRule('block', key, blocks[key])\n      }\n\n      for (const key in inlines) {\n        is[key] = resolveNodeRule('inline', key, inlines[key])\n      }\n\n      mergeWith(schema.document, d, customizer)\n      mergeWith(schema.blocks, bs, customizer)\n      mergeWith(schema.inlines, is, customizer)\n    })\n\n  return schema\n}\n\n/**\n * Resolve a document rule `obj`.\n *\n * @param {Object} obj\n * @return {Object}\n */\n\nfunction resolveDocumentRule(obj) {\n  return {\n    data: {},\n    nodes: null,\n    ...obj,\n  }\n}\n\n/**\n * Resolve a node rule with `type` from `obj`.\n *\n * @param {String} object\n * @param {String} type\n * @param {Object} obj\n * @return {Object}\n */\n\nfunction resolveNodeRule(object, type, obj) {\n  return {\n    data: {},\n    isVoid: null,\n    nodes: null,\n    first: null,\n    last: null,\n    parent: null,\n    text: null,\n    ...obj,\n  }\n}\n\n/**\n * A Lodash customizer for merging schema definitions. Special cases `objects`\n * and `types` arrays to be unioned, and ignores new `null` values.\n *\n * @param {Mixed} target\n * @param {Mixed} source\n * @return {Array|Void}\n */\n\nfunction customizer(target, source, key) {\n  if (key == 'objects' || key == 'types') {\n    return target == null ? source : target.concat(source)\n  } else {\n    return source == null ? target : source\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nSchema.prototype[MODEL_TYPES.SCHEMA] = true\n\n/**\n * Memoize read methods.\n */\n\nmemoize(Schema.prototype, ['getParentRules'])\n\n/**\n * Export.\n *\n * @type {Schema}\n */\n\nexport default Schema\n","import isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport { Record, Set, List, Map } from 'immutable'\n\nimport MODEL_TYPES from '../constants/model-types'\nimport Change from './change'\nimport Data from './data'\nimport Document from './document'\nimport History from './history'\nimport Range from './range'\nimport Schema from './schema'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: new Map(),\n  decorations: null,\n  document: Document.create(),\n  history: History.create(),\n  schema: Schema.create(),\n  selection: Range.create(),\n}\n\n/**\n * Value.\n *\n * @type {Value}\n */\n\nclass Value extends Record(DEFAULTS) {\n  /**\n   * Create a new `Value` with `attrs`.\n   *\n   * @param {Object|Value} attrs\n   * @param {Object} options\n   * @return {Value}\n   */\n\n  static create(attrs = {}, options = {}) {\n    if (Value.isValue(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Value.fromJSON(attrs, options)\n    }\n\n    throw new Error(\n      `\\`Value.create\\` only accepts objects or values, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable value properties from `attrs`.\n   *\n   * @param {Object|Value} attrs\n   * @return {Object}\n   */\n\n  static createProperties(attrs = {}) {\n    if (Value.isValue(attrs)) {\n      return {\n        data: attrs.data,\n        decorations: attrs.decorations,\n        schema: attrs.schema,\n      }\n    }\n\n    if (isPlainObject(attrs)) {\n      const props = {}\n      if ('data' in attrs) props.data = Data.create(attrs.data)\n      if ('decorations' in attrs)\n        props.decorations = Range.createList(attrs.decorations)\n      if ('schema' in attrs) props.schema = Schema.create(attrs.schema)\n      return props\n    }\n\n    throw new Error(\n      `\\`Value.createProperties\\` only accepts objects or values, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Value` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @param {Object} options\n   *   @property {Boolean} normalize\n   *   @property {Array} plugins\n   * @return {Value}\n   */\n\n  static fromJSON(object, options = {}) {\n    let { document = {}, selection = {}, schema = {} } = object\n\n    let data = new Map()\n\n    document = Document.fromJSON(document)\n    selection = Range.fromJSON(selection)\n    schema = Schema.fromJSON(schema)\n\n    // Allow plugins to set a default value for `data`.\n    if (options.plugins) {\n      for (const plugin of options.plugins) {\n        if (plugin.data) data = data.merge(plugin.data)\n      }\n    }\n\n    // Then merge in the `data` provided.\n    if ('data' in object) {\n      data = data.merge(object.data)\n    }\n\n    if (selection.isUnset) {\n      const text = document.getFirstText()\n      if (text) selection = selection.collapseToStartOf(text)\n    }\n\n    let value = new Value({\n      data,\n      document,\n      selection,\n      schema,\n    })\n\n    if (options.normalize !== false) {\n      value = value.change({ save: false }).normalize().value\n    }\n\n    return value\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Value.fromJSON\n\n  /**\n   * Check if a `value` is a `Value`.\n   *\n   * @param {Any} value\n   * @return {Boolean}\n   */\n\n  static isValue(value) {\n    return !!(value && value[MODEL_TYPES.VALUE])\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'value'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Are there undoable events?\n   *\n   * @return {Boolean}\n   */\n\n  get hasUndos() {\n    return this.history.undos.size > 0\n  }\n\n  /**\n   * Are there redoable events?\n   *\n   * @return {Boolean}\n   */\n\n  get hasRedos() {\n    return this.history.redos.size > 0\n  }\n\n  /**\n   * Is the current selection blurred?\n   *\n   * @return {Boolean}\n   */\n\n  get isBlurred() {\n    return this.selection.isBlurred\n  }\n\n  /**\n   * Is the current selection focused?\n   *\n   * @return {Boolean}\n   */\n\n  get isFocused() {\n    return this.selection.isFocused\n  }\n\n  /**\n   * Is the current selection collapsed?\n   *\n   * @return {Boolean}\n   */\n\n  get isCollapsed() {\n    return this.selection.isCollapsed\n  }\n\n  /**\n   * Is the current selection expanded?\n   *\n   * @return {Boolean}\n   */\n\n  get isExpanded() {\n    return this.selection.isExpanded\n  }\n\n  /**\n   * Is the current selection backward?\n   *\n   * @return {Boolean} isBackward\n   */\n\n  get isBackward() {\n    return this.selection.isBackward\n  }\n\n  /**\n   * Is the current selection forward?\n   *\n   * @return {Boolean}\n   */\n\n  get isForward() {\n    return this.selection.isForward\n  }\n\n  /**\n   * Get the current start key.\n   *\n   * @return {String}\n   */\n\n  get startKey() {\n    return this.selection.startKey\n  }\n\n  /**\n   * Get the current end key.\n   *\n   * @return {String}\n   */\n\n  get endKey() {\n    return this.selection.endKey\n  }\n\n  /**\n   * Get the current start offset.\n   *\n   * @return {String}\n   */\n\n  get startOffset() {\n    return this.selection.startOffset\n  }\n\n  /**\n   * Get the current end offset.\n   *\n   * @return {String}\n   */\n\n  get endOffset() {\n    return this.selection.endOffset\n  }\n\n  /**\n   * Get the current anchor key.\n   *\n   * @return {String}\n   */\n\n  get anchorKey() {\n    return this.selection.anchorKey\n  }\n\n  /**\n   * Get the current focus key.\n   *\n   * @return {String}\n   */\n\n  get focusKey() {\n    return this.selection.focusKey\n  }\n\n  /**\n   * Get the current anchor offset.\n   *\n   * @return {String}\n   */\n\n  get anchorOffset() {\n    return this.selection.anchorOffset\n  }\n\n  /**\n   * Get the current focus offset.\n   *\n   * @return {String}\n   */\n\n  get focusOffset() {\n    return this.selection.focusOffset\n  }\n\n  /**\n   * Get the current start text node's closest block parent.\n   *\n   * @return {Block}\n   */\n\n  get startBlock() {\n    return this.startKey && this.document.getClosestBlock(this.startKey)\n  }\n\n  /**\n   * Get the current end text node's closest block parent.\n   *\n   * @return {Block}\n   */\n\n  get endBlock() {\n    return this.endKey && this.document.getClosestBlock(this.endKey)\n  }\n\n  /**\n   * Get the current anchor text node's closest block parent.\n   *\n   * @return {Block}\n   */\n\n  get anchorBlock() {\n    return this.anchorKey && this.document.getClosestBlock(this.anchorKey)\n  }\n\n  /**\n   * Get the current focus text node's closest block parent.\n   *\n   * @return {Block}\n   */\n\n  get focusBlock() {\n    return this.focusKey && this.document.getClosestBlock(this.focusKey)\n  }\n\n  /**\n   * Get the current start text node's closest inline parent.\n   *\n   * @return {Inline}\n   */\n\n  get startInline() {\n    return this.startKey && this.document.getClosestInline(this.startKey)\n  }\n\n  /**\n   * Get the current end text node's closest inline parent.\n   *\n   * @return {Inline}\n   */\n\n  get endInline() {\n    return this.endKey && this.document.getClosestInline(this.endKey)\n  }\n\n  /**\n   * Get the current anchor text node's closest inline parent.\n   *\n   * @return {Inline}\n   */\n\n  get anchorInline() {\n    return this.anchorKey && this.document.getClosestInline(this.anchorKey)\n  }\n\n  /**\n   * Get the current focus text node's closest inline parent.\n   *\n   * @return {Inline}\n   */\n\n  get focusInline() {\n    return this.focusKey && this.document.getClosestInline(this.focusKey)\n  }\n\n  /**\n   * Get the current start text node.\n   *\n   * @return {Text}\n   */\n\n  get startText() {\n    return this.startKey && this.document.getDescendant(this.startKey)\n  }\n\n  /**\n   * Get the current end node.\n   *\n   * @return {Text}\n   */\n\n  get endText() {\n    return this.endKey && this.document.getDescendant(this.endKey)\n  }\n\n  /**\n   * Get the current anchor node.\n   *\n   * @return {Text}\n   */\n\n  get anchorText() {\n    return this.anchorKey && this.document.getDescendant(this.anchorKey)\n  }\n\n  /**\n   * Get the current focus node.\n   *\n   * @return {Text}\n   */\n\n  get focusText() {\n    return this.focusKey && this.document.getDescendant(this.focusKey)\n  }\n\n  /**\n   * Get the next block node.\n   *\n   * @return {Block}\n   */\n\n  get nextBlock() {\n    return this.endKey && this.document.getNextBlock(this.endKey)\n  }\n\n  /**\n   * Get the previous block node.\n   *\n   * @return {Block}\n   */\n\n  get previousBlock() {\n    return this.startKey && this.document.getPreviousBlock(this.startKey)\n  }\n\n  /**\n   * Get the next inline node.\n   *\n   * @return {Inline}\n   */\n\n  get nextInline() {\n    return this.endKey && this.document.getNextInline(this.endKey)\n  }\n\n  /**\n   * Get the previous inline node.\n   *\n   * @return {Inline}\n   */\n\n  get previousInline() {\n    return this.startKey && this.document.getPreviousInline(this.startKey)\n  }\n\n  /**\n   * Get the next text node.\n   *\n   * @return {Text}\n   */\n\n  get nextText() {\n    return this.endKey && this.document.getNextText(this.endKey)\n  }\n\n  /**\n   * Get the previous text node.\n   *\n   * @return {Text}\n   */\n\n  get previousText() {\n    return this.startKey && this.document.getPreviousText(this.startKey)\n  }\n\n  /**\n   * Get the characters in the current selection.\n   *\n   * @return {List<Character>}\n   */\n\n  get characters() {\n    return this.selection.isUnset\n      ? new List()\n      : this.document.getCharactersAtRange(this.selection)\n  }\n\n  /**\n   * Get the marks of the current selection.\n   *\n   * @return {Set<Mark>}\n   */\n\n  get marks() {\n    return this.selection.isUnset\n      ? new Set()\n      : this.selection.marks || this.document.getMarksAtRange(this.selection)\n  }\n\n  /**\n   * Get the active marks of the current selection.\n   *\n   * @return {Set<Mark>}\n   */\n\n  get activeMarks() {\n    return this.selection.isUnset\n      ? new Set()\n      : this.selection.marks ||\n          this.document.getActiveMarksAtRange(this.selection)\n  }\n\n  /**\n   * Get the block nodes in the current selection.\n   *\n   * @return {List<Block>}\n   */\n\n  get blocks() {\n    return this.selection.isUnset\n      ? new List()\n      : this.document.getBlocksAtRange(this.selection)\n  }\n\n  /**\n   * Get the fragment of the current selection.\n   *\n   * @return {Document}\n   */\n\n  get fragment() {\n    return this.selection.isUnset\n      ? Document.create()\n      : this.document.getFragmentAtRange(this.selection)\n  }\n\n  /**\n   * Get the inline nodes in the current selection.\n   *\n   * @return {List<Inline>}\n   */\n\n  get inlines() {\n    return this.selection.isUnset\n      ? new List()\n      : this.document.getInlinesAtRange(this.selection)\n  }\n\n  /**\n   * Get the text nodes in the current selection.\n   *\n   * @return {List<Text>}\n   */\n\n  get texts() {\n    return this.selection.isUnset\n      ? new List()\n      : this.document.getTextsAtRange(this.selection)\n  }\n\n  /**\n   * Check whether the selection is empty.\n   *\n   * @return {Boolean}\n   */\n\n  get isEmpty() {\n    if (this.isCollapsed) return true\n    if (this.endOffset != 0 && this.startOffset != 0) return false\n    return this.fragment.isEmpty\n  }\n\n  /**\n   * Check whether the selection is collapsed in a void node.\n   *\n   * @return {Boolean}\n   */\n\n  get isInVoid() {\n    if (this.isExpanded) return false\n    return this.document.hasVoidParent(this.startKey)\n  }\n\n  /**\n   * Create a new `Change` with the current value as a starting point.\n   *\n   * @param {Object} attrs\n   * @return {Change}\n   */\n\n  change(attrs = {}) {\n    return new Change({ ...attrs, value: this })\n  }\n\n  /**\n   * Return a JSON representation of the value.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      document: this.document.toJSON(options),\n    }\n\n    if (options.preserveData) {\n      object.data = this.data.toJSON()\n    }\n\n    if (options.preserveDecorations) {\n      object.decorations = this.decorations\n        ? this.decorations.toArray().map(d => d.toJSON())\n        : null\n    }\n\n    if (options.preserveHistory) {\n      object.history = this.history.toJSON()\n    }\n\n    if (options.preserveSelection) {\n      object.selection = this.selection.toJSON()\n    }\n\n    if (options.preserveSchema) {\n      object.schema = this.schema.toJSON()\n    }\n\n    if (options.preserveSelection && !options.preserveKeys) {\n      const { document, selection } = this\n      object.selection.anchorPath = selection.isSet\n        ? document.getPath(selection.anchorKey)\n        : null\n      object.selection.focusPath = selection.isSet\n        ? document.getPath(selection.focusKey)\n        : null\n      delete object.selection.anchorKey\n      delete object.selection.focusKey\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS(options) {\n    return this.toJSON(options)\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nValue.prototype[MODEL_TYPES.VALUE] = true\n\n/**\n * Export.\n */\n\nexport default Value\n","import isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport { List, Record } from 'immutable'\n\nimport MODEL_TYPES from '../constants/model-types'\nimport OPERATION_ATTRIBUTES from '../constants/operation-attributes'\nimport Mark from './mark'\nimport Node from './node'\nimport Range from './range'\nimport Value from './value'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  length: undefined,\n  mark: undefined,\n  marks: undefined,\n  newPath: undefined,\n  node: undefined,\n  offset: undefined,\n  path: undefined,\n  position: undefined,\n  properties: undefined,\n  selection: undefined,\n  target: undefined,\n  text: undefined,\n  type: undefined,\n  value: undefined,\n}\n\n/**\n * Operation.\n *\n * @type {Operation}\n */\n\nclass Operation extends Record(DEFAULTS) {\n  /**\n   * Create a new `Operation` with `attrs`.\n   *\n   * @param {Object|Array|List|String|Operation} attrs\n   * @return {Operation}\n   */\n\n  static create(attrs = {}) {\n    if (Operation.isOperation(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Operation.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Operation.create\\` only accepts objects or operations, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Operations` from `elements`.\n   *\n   * @param {Array<Operation|Object>|List<Operation|Object>} elements\n   * @return {List<Operation>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Operation.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Operation.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a `Operation` from a JSON `object`.\n   *\n   * @param {Object|Operation} object\n   * @return {Operation}\n   */\n\n  static fromJSON(object) {\n    if (Operation.isOperation(object)) {\n      return object\n    }\n\n    const { type, value } = object\n    const ATTRIBUTES = OPERATION_ATTRIBUTES[type]\n    const attrs = { type }\n\n    if (!ATTRIBUTES) {\n      throw new Error(\n        `\\`Operation.fromJSON\\` was passed an unrecognized operation type: \"${type}\"`\n      )\n    }\n\n    for (const key of ATTRIBUTES) {\n      let v = object[key]\n\n      if (v === undefined) {\n        // Skip keys for objects that should not be serialized, and are only used\n        // for providing the local-only invert behavior for the history stack.\n        if (key == 'document') continue\n        if (key == 'selection') continue\n        if (key == 'value') continue\n        if (key == 'node' && type != 'insert_node') continue\n\n        throw new Error(\n          `\\`Operation.fromJSON\\` was passed a \"${type}\" operation without the required \"${key}\" attribute.`\n        )\n      }\n\n      if (key == 'mark') {\n        v = Mark.create(v)\n      }\n\n      if (key == 'marks' && v != null) {\n        v = Mark.createSet(v)\n      }\n\n      if (key == 'node') {\n        v = Node.create(v)\n      }\n\n      if (key == 'selection') {\n        v = Range.create(v)\n      }\n\n      if (key == 'value') {\n        v = Value.create(v)\n      }\n\n      if (key == 'properties' && type == 'merge_node') {\n        v = Node.createProperties(v)\n      }\n\n      if (key == 'properties' && type == 'set_mark') {\n        v = Mark.createProperties(v)\n      }\n\n      if (key == 'properties' && type == 'set_node') {\n        v = Node.createProperties(v)\n      }\n\n      if (key == 'properties' && type == 'set_selection') {\n        const { anchorKey, focusKey, ...rest } = v\n        v = Range.createProperties(rest)\n\n        if (anchorKey !== undefined) {\n          v.anchorPath =\n            anchorKey === null ? null : value.document.getPath(anchorKey)\n        }\n\n        if (focusKey !== undefined) {\n          v.focusPath =\n            focusKey === null ? null : value.document.getPath(focusKey)\n        }\n      }\n\n      if (key == 'properties' && type == 'set_value') {\n        v = Value.createProperties(v)\n      }\n\n      if (key == 'properties' && type == 'split_node') {\n        v = Node.createProperties(v)\n      }\n\n      attrs[key] = v\n    }\n\n    const node = new Operation(attrs)\n    return node\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Operation.fromJSON\n\n  /**\n   * Check if `any` is a `Operation`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isOperation(any) {\n    return !!(any && any[MODEL_TYPES.OPERATION])\n  }\n\n  /**\n   * Check if `any` is a listof operations.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isOperationList(any) {\n    return List.isList(any) && any.every(item => Operation.isOperation(item))\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'operation'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Return a JSON representation of the operation.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const { object, type } = this\n    const json = { object, type }\n    const ATTRIBUTES = OPERATION_ATTRIBUTES[type]\n\n    for (const key of ATTRIBUTES) {\n      let value = this[key]\n\n      // Skip keys for objects that should not be serialized, and are only used\n      // for providing the local-only invert behavior for the history stack.\n      if (key == 'document') continue\n      if (key == 'selection') continue\n      if (key == 'value') continue\n      if (key == 'node' && type != 'insert_node') continue\n\n      if (key == 'mark' || key == 'marks' || key == 'node') {\n        value = value.toJSON()\n      }\n\n      if (key == 'properties' && type == 'merge_node') {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      if (key == 'properties' && type == 'set_mark') {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      if (key == 'properties' && type == 'set_node') {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('isVoid' in value) v.isVoid = value.isVoid\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      if (key == 'properties' && type == 'set_selection') {\n        const v = {}\n        if ('anchorOffset' in value) v.anchorOffset = value.anchorOffset\n        if ('anchorPath' in value) v.anchorPath = value.anchorPath\n        if ('focusOffset' in value) v.focusOffset = value.focusOffset\n        if ('focusPath' in value) v.focusPath = value.focusPath\n        if ('isBackward' in value) v.isBackward = value.isBackward\n        if ('isFocused' in value) v.isFocused = value.isFocused\n        if ('marks' in value)\n          v.marks = value.marks == null ? null : value.marks.toJSON()\n        value = v\n      }\n\n      if (key == 'properties' && type == 'set_value') {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('decorations' in value) v.decorations = value.decorations.toJS()\n        if ('schema' in value) v.schema = value.schema.toJS()\n        value = v\n      }\n\n      if (key == 'properties' && type == 'split_node') {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      json[key] = value\n    }\n\n    return json\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS(options) {\n    return this.toJSON(options)\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nOperation.prototype[MODEL_TYPES.OPERATION] = true\n\n/**\n * Export.\n *\n * @type {Operation}\n */\n\nexport default Operation\n","import Debug from 'debug'\nimport pick from 'lodash/pick'\n\nimport Operation from '../models/operation'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:operation:invert')\n\n/**\n * Invert an `op`.\n *\n * @param {Object} op\n * @return {Object}\n */\n\nfunction invertOperation(op) {\n  op = Operation.create(op)\n  const { type } = op\n  debug(type, op)\n\n  /**\n   * Insert node.\n   */\n\n  if (type == 'insert_node') {\n    const inverse = op.set('type', 'remove_node')\n    return inverse\n  }\n\n  /**\n   * Remove node.\n   */\n\n  if (type == 'remove_node') {\n    const inverse = op.set('type', 'insert_node')\n    return inverse\n  }\n\n  /**\n   * Move node.\n   */\n\n  if (type == 'move_node') {\n    const { newPath, path } = op\n    let inversePath = newPath\n    let inverseNewPath = path\n\n    const pathLast = path.length - 1\n    const newPathLast = newPath.length - 1\n\n    // If the node's old position was a left sibling of an ancestor of\n    // its new position, we need to adjust part of the path by -1.\n    if (\n      path.length < inversePath.length &&\n      path.slice(0, pathLast).every((e, i) => e == inversePath[i]) &&\n      path[pathLast] < inversePath[pathLast]\n    ) {\n      inversePath = inversePath\n        .slice(0, pathLast)\n        .concat([inversePath[pathLast] - 1])\n        .concat(inversePath.slice(pathLast + 1, inversePath.length))\n    }\n\n    // If the node's new position is an ancestor of the old position,\n    // or a left sibling of an ancestor of its old position, we need\n    // to adjust part of the path by 1.\n    if (\n      newPath.length < inverseNewPath.length &&\n      newPath.slice(0, newPathLast).every((e, i) => e == inverseNewPath[i]) &&\n      newPath[newPathLast] <= inverseNewPath[newPathLast]\n    ) {\n      inverseNewPath = inverseNewPath\n        .slice(0, newPathLast)\n        .concat([inverseNewPath[newPathLast] + 1])\n        .concat(inverseNewPath.slice(newPathLast + 1, inverseNewPath.length))\n    }\n\n    const inverse = op.set('path', inversePath).set('newPath', inverseNewPath)\n    return inverse\n  }\n\n  /**\n   * Merge node.\n   */\n\n  if (type == 'merge_node') {\n    const { path } = op\n    const { length } = path\n    const last = length - 1\n    const inversePath = path.slice(0, last).concat([path[last] - 1])\n    const inverse = op.set('type', 'split_node').set('path', inversePath)\n    return inverse\n  }\n\n  /**\n   * Split node.\n   */\n\n  if (type == 'split_node') {\n    const { path } = op\n    const { length } = path\n    const last = length - 1\n    const inversePath = path.slice(0, last).concat([path[last] + 1])\n    const inverse = op.set('type', 'merge_node').set('path', inversePath)\n    return inverse\n  }\n\n  /**\n   * Set node.\n   */\n\n  if (type == 'set_node') {\n    const { properties, node } = op\n    const inverseNode = node.merge(properties)\n    const inverseProperties = pick(node, Object.keys(properties))\n    const inverse = op\n      .set('node', inverseNode)\n      .set('properties', inverseProperties)\n    return inverse\n  }\n\n  /**\n   * Insert text.\n   */\n\n  if (type == 'insert_text') {\n    const inverse = op.set('type', 'remove_text')\n    return inverse\n  }\n\n  /**\n   * Remove text.\n   */\n\n  if (type == 'remove_text') {\n    const inverse = op.set('type', 'insert_text')\n    return inverse\n  }\n\n  /**\n   * Add mark.\n   */\n\n  if (type == 'add_mark') {\n    const inverse = op.set('type', 'remove_mark')\n    return inverse\n  }\n\n  /**\n   * Remove mark.\n   */\n\n  if (type == 'remove_mark') {\n    const inverse = op.set('type', 'add_mark')\n    return inverse\n  }\n\n  /**\n   * Set mark.\n   */\n\n  if (type == 'set_mark') {\n    const { properties, mark } = op\n    const inverseMark = mark.merge(properties)\n    const inverseProperties = pick(mark, Object.keys(properties))\n    const inverse = op\n      .set('mark', inverseMark)\n      .set('properties', inverseProperties)\n    return inverse\n  }\n\n  /**\n   * Set selection.\n   */\n\n  if (type == 'set_selection') {\n    const { properties, selection, value } = op\n    const { anchorPath, focusPath, ...props } = properties\n    const { document } = value\n\n    if (anchorPath !== undefined) {\n      props.anchorKey =\n        anchorPath === null ? null : document.assertPath(anchorPath).key\n    }\n\n    if (focusPath !== undefined) {\n      props.focusKey =\n        focusPath === null ? null : document.assertPath(focusPath).key\n    }\n\n    const inverseSelection = selection.merge(props)\n    const inverseProps = pick(selection, Object.keys(props))\n\n    if (anchorPath !== undefined) {\n      inverseProps.anchorPath =\n        inverseProps.anchorKey === null\n          ? null\n          : document.getPath(inverseProps.anchorKey)\n      delete inverseProps.anchorKey\n    }\n\n    if (focusPath !== undefined) {\n      inverseProps.focusPath =\n        inverseProps.focusKey === null\n          ? null\n          : document.getPath(inverseProps.focusKey)\n      delete inverseProps.focusKey\n    }\n\n    const inverse = op\n      .set('selection', inverseSelection)\n      .set('properties', inverseProps)\n    return inverse\n  }\n\n  /**\n   * Set value.\n   */\n\n  if (type == 'set_value') {\n    const { properties, value } = op\n    const inverseValue = value.merge(properties)\n    const inverseProperties = pick(value, Object.keys(properties))\n    const inverse = op\n      .set('value', inverseValue)\n      .set('properties', inverseProperties)\n    return inverse\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default invertOperation\n","import invert from '../operations/invert'\nimport omit from 'lodash/omit'\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nconst Changes = {}\n\n/**\n * Redo to the next value in the history.\n *\n * @param {Change} change\n */\n\nChanges.redo = change => {\n  let { value } = change\n  let { history } = value\n  if (!history) return\n\n  let { undos, redos } = history\n  const next = redos.peek()\n  if (!next) return\n\n  // Shift the next value into the undo stack.\n  redos = redos.pop()\n  undos = undos.push(next)\n\n  // Replay the next operations.\n  next.forEach(op => {\n    const { type, properties } = op\n\n    // When the operation mutates the selection, omit its `isFocused` value to\n    // prevent the editor focus from changing during redoing.\n    if (type == 'set_selection') {\n      op = op.set('properties', omit(properties, 'isFocused'))\n    }\n\n    change.applyOperation(op, { save: false })\n  })\n\n  // Update the history.\n  value = change.value\n  history = history.set('undos', undos).set('redos', redos)\n  value = value.set('history', history)\n  change.value = value\n}\n\n/**\n * Undo the previous operations in the history.\n *\n * @param {Change} change\n */\n\nChanges.undo = change => {\n  let { value } = change\n  let { history } = value\n  if (!history) return\n\n  let { undos, redos } = history\n  const previous = undos.peek()\n  if (!previous) return\n\n  // Shift the previous operations into the redo stack.\n  undos = undos.pop()\n  redos = redos.push(previous)\n\n  // Replay the inverse of the previous operations.\n  previous\n    .slice()\n    .reverse()\n    .map(invert)\n    .forEach(inverse => {\n      const { type, properties } = inverse\n\n      // When the operation mutates the selection, omit its `isFocused` value to\n      // prevent the editor focus from changing during undoing.\n      if (type == 'set_selection') {\n        inverse = inverse.set('properties', omit(properties, 'isFocused'))\n      }\n\n      change.applyOperation(inverse, { save: false })\n    })\n\n  // Update the history.\n  value = change.value\n  history = history.set('undos', undos).set('redos', redos)\n  value = value.set('history', history)\n  change.value = value\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Changes\n","import isEmpty from 'is-empty'\nimport pick from 'lodash/pick'\n\nimport Range from '../models/range'\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nconst Changes = {}\n\n/**\n * Set `properties` on the selection.\n *\n * @param {Change} change\n * @param {Object} properties\n */\n\nChanges.select = (change, properties, options = {}) => {\n  properties = Range.createProperties(properties)\n\n  const { snapshot = false } = options\n  const { value } = change\n  const { document, selection } = value\n  const props = {}\n  const sel = selection.toJSON()\n  const next = selection.merge(properties).normalize(document)\n  properties = pick(next, Object.keys(properties))\n\n  // Remove any properties that are already equal to the current selection. And\n  // create a dictionary of the previous values for all of the properties that\n  // are being changed, for the inverse operation.\n  for (const k in properties) {\n    if (snapshot == false && properties[k] == sel[k]) continue\n    props[k] = properties[k]\n  }\n\n  // If the selection moves, clear any marks, unless the new selection\n  // properties change the marks in some way.\n  const moved = ['anchorKey', 'anchorOffset', 'focusKey', 'focusOffset'].some(\n    p => props.hasOwnProperty(p)\n  )\n\n  if (sel.marks && properties.marks == sel.marks && moved) {\n    props.marks = null\n  }\n\n  // If there are no new properties to set, abort.\n  if (isEmpty(props)) {\n    return\n  }\n\n  // Apply the operation.\n  change.applyOperation(\n    {\n      type: 'set_selection',\n      value,\n      properties: props,\n      selection: sel,\n    },\n    snapshot ? { skip: false, merge: false } : {}\n  )\n}\n\n/**\n * Select the whole document.\n *\n * @param {Change} change\n */\n\nChanges.selectAll = change => {\n  const { value } = change\n  const { document, selection } = value\n  const next = selection.moveToRangeOf(document)\n  change.select(next)\n}\n\n/**\n * Snapshot the current selection.\n *\n * @param {Change} change\n */\n\nChanges.snapshotSelection = change => {\n  const { value } = change\n  const { selection } = value\n  change.select(selection, { snapshot: true })\n}\n\n/**\n * Move the anchor point backward, accounting for being at the start of a block.\n *\n * @param {Change} change\n */\n\nChanges.moveAnchorCharBackward = change => {\n  const { value } = change\n  const { document, selection, anchorText, anchorBlock } = value\n  const { anchorOffset } = selection\n  const previousText = document.getPreviousText(anchorText.key)\n  const isInVoid = document.hasVoidParent(anchorText.key)\n  const isPreviousInVoid =\n    previousText && document.hasVoidParent(previousText.key)\n\n  if (!isInVoid && anchorOffset > 0) {\n    change.moveAnchor(-1)\n    return\n  }\n\n  if (!previousText) {\n    return\n  }\n\n  change.moveAnchorToEndOf(previousText)\n\n  if (!isInVoid && !isPreviousInVoid && anchorBlock.hasNode(previousText.key)) {\n    change.moveAnchor(-1)\n  }\n}\n\n/**\n * Move the anchor point forward, accounting for being at the end of a block.\n *\n * @param {Change} change\n */\n\nChanges.moveAnchorCharForward = change => {\n  const { value } = change\n  const { document, selection, anchorText, anchorBlock } = value\n  const { anchorOffset } = selection\n  const nextText = document.getNextText(anchorText.key)\n  const isInVoid = document.hasVoidParent(anchorText.key)\n  const isNextInVoid = nextText && document.hasVoidParent(nextText.key)\n\n  if (!isInVoid && anchorOffset < anchorText.text.length) {\n    change.moveAnchor(1)\n    return\n  }\n\n  if (!nextText) {\n    return\n  }\n\n  change.moveAnchorToStartOf(nextText)\n\n  if (!isInVoid && !isNextInVoid && anchorBlock.hasNode(nextText.key)) {\n    change.moveAnchor(1)\n  }\n}\n\n/**\n * Move the focus point backward, accounting for being at the start of a block.\n *\n * @param {Change} change\n */\n\nChanges.moveFocusCharBackward = change => {\n  const { value } = change\n  const { document, selection, focusText, focusBlock } = value\n  const { focusOffset } = selection\n  const previousText = document.getPreviousText(focusText.key)\n  const isInVoid = document.hasVoidParent(focusText.key)\n  const isPreviousInVoid =\n    previousText && document.hasVoidParent(previousText.key)\n\n  if (!isInVoid && focusOffset > 0) {\n    change.moveFocus(-1)\n    return\n  }\n\n  if (!previousText) {\n    return\n  }\n\n  change.moveFocusToEndOf(previousText)\n\n  if (!isInVoid && !isPreviousInVoid && focusBlock.hasNode(previousText.key)) {\n    change.moveFocus(-1)\n  }\n}\n\n/**\n * Move the focus point forward, accounting for being at the end of a block.\n *\n * @param {Change} change\n */\n\nChanges.moveFocusCharForward = change => {\n  const { value } = change\n  const { document, selection, focusText, focusBlock } = value\n  const { focusOffset } = selection\n  const nextText = document.getNextText(focusText.key)\n  const isInVoid = document.hasVoidParent(focusText.key)\n  const isNextInVoid = nextText && document.hasVoidParent(nextText.key)\n\n  if (!isInVoid && focusOffset < focusText.text.length) {\n    change.moveFocus(1)\n    return\n  }\n\n  if (!nextText) {\n    return\n  }\n\n  change.moveFocusToStartOf(nextText)\n\n  if (!isInVoid && !isNextInVoid && focusBlock.hasNode(nextText.key)) {\n    change.moveFocus(1)\n  }\n}\n\n/**\n * Mix in move methods.\n */\n\nconst MOVE_DIRECTIONS = ['Forward', 'Backward']\n\nMOVE_DIRECTIONS.forEach(direction => {\n  const anchor = `moveAnchorChar${direction}`\n  const focus = `moveFocusChar${direction}`\n\n  Changes[`moveChar${direction}`] = change => {\n    change[anchor]()[focus]()\n  }\n\n  Changes[`moveStartChar${direction}`] = change => {\n    if (change.value.isBackward) {\n      change[focus]()\n    } else {\n      change[anchor]()\n    }\n  }\n\n  Changes[`moveEndChar${direction}`] = change => {\n    if (change.value.isBackward) {\n      change[anchor]()\n    } else {\n      change[focus]()\n    }\n  }\n\n  Changes[`extendChar${direction}`] = change => {\n    change[`moveFocusChar${direction}`]()\n  }\n\n  Changes[`collapseChar${direction}`] = change => {\n    const collapse =\n      direction == 'Forward' ? 'collapseToEnd' : 'collapseToStart'\n    change[collapse]()[`moveChar${direction}`]()\n  }\n})\n\n/**\n * Mix in alias methods.\n */\n\nconst ALIAS_METHODS = [\n  ['collapseLineBackward', 'collapseToStartOfBlock'],\n  ['collapseLineForward', 'collapseToEndOfBlock'],\n  ['extendLineBackward', 'extendToStartOfBlock'],\n  ['extendLineForward', 'extendToEndOfBlock'],\n]\n\nALIAS_METHODS.forEach(([alias, method]) => {\n  Changes[alias] = function(change, ...args) {\n    change[method](change, ...args)\n  }\n})\n\n/**\n * Mix in selection changes that are just a proxy for the selection method.\n */\n\nconst PROXY_TRANSFORMS = [\n  'blur',\n  'collapseTo',\n  'collapseToAnchor',\n  'collapseToEnd',\n  'collapseToEndOf',\n  'collapseToFocus',\n  'collapseToStart',\n  'collapseToStartOf',\n  'extend',\n  'extendTo',\n  'extendToEndOf',\n  'extendToStartOf',\n  'flip',\n  'focus',\n  'move',\n  'moveAnchor',\n  'moveAnchorOffsetTo',\n  'moveAnchorTo',\n  'moveAnchorToEndOf',\n  'moveAnchorToStartOf',\n  'moveEnd',\n  'moveEndOffsetTo',\n  'moveEndTo',\n  'moveFocus',\n  'moveFocusOffsetTo',\n  'moveFocusTo',\n  'moveFocusToEndOf',\n  'moveFocusToStartOf',\n  'moveOffsetsTo',\n  'moveStart',\n  'moveStartOffsetTo',\n  'moveStartTo',\n  'moveTo',\n  'moveToEnd',\n  'moveToEndOf',\n  'moveToRangeOf',\n  'moveToStart',\n  'moveToStartOf',\n  'deselect',\n]\n\nPROXY_TRANSFORMS.forEach(method => {\n  Changes[method] = (change, ...args) => {\n    const normalize = method != 'deselect'\n    const { value } = change\n    const { document, selection } = value\n    let next = selection[method](...args)\n    if (normalize) next = next.normalize(document)\n    change.select(next)\n  }\n})\n\n/**\n * Mix in node-related changes.\n */\n\nconst PREFIXES = [\n  'moveTo',\n  'moveAnchorTo',\n  'moveFocusTo',\n  'moveStartTo',\n  'moveEndTo',\n  'collapseTo',\n  'extendTo',\n]\n\nconst DIRECTIONS = ['Next', 'Previous']\n\nconst OBJECTS = ['Block', 'Inline', 'Text']\n\nPREFIXES.forEach(prefix => {\n  const edges = ['Start', 'End']\n\n  if (prefix == 'moveTo') {\n    edges.push('Range')\n  }\n\n  edges.forEach(edge => {\n    const method = `${prefix}${edge}Of`\n\n    OBJECTS.forEach(object => {\n      const getNode = object == 'Text' ? 'getNode' : `getClosest${object}`\n\n      Changes[`${method}${object}`] = change => {\n        const { value } = change\n        const { document, selection } = value\n        const node = document[getNode](selection.startKey)\n        if (!node) return\n        change[method](node)\n      }\n\n      DIRECTIONS.forEach(direction => {\n        const getDirectionNode = `get${direction}${object}`\n        const directionKey = direction == 'Next' ? 'startKey' : 'endKey'\n\n        Changes[`${method}${direction}${object}`] = change => {\n          const { value } = change\n          const { document, selection } = value\n          const node = document[getNode](selection[directionKey])\n          if (!node) return\n          const target = document[getDirectionNode](node.key)\n          if (!target) return\n          change[method](target)\n        }\n      })\n    })\n  })\n})\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Changes\n","import Value from '../models/value'\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nconst Changes = {}\n\n/**\n * Set `properties` on the value.\n *\n * @param {Change} change\n * @param {Object|Value} properties\n * @param {Object} options\n */\n\nChanges.setValue = (change, properties, options = {}) => {\n  properties = Value.createProperties(properties)\n  const { value } = change\n\n  change.applyOperation(\n    {\n      type: 'set_value',\n      properties,\n      value,\n    },\n    options\n  )\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Changes\n","/**\n * Changes.\n *\n * @type {Object}\n */\n\nconst Changes = {}\n\n/**\n * Normalize the value with its schema.\n *\n * @param {Change} change\n */\n\nChanges.normalize = change => {\n  change.normalizeDocument()\n}\n\n/**\n * Normalize the document with the value's schema.\n *\n * @param {Change} change\n */\n\nChanges.normalizeDocument = change => {\n  const { value } = change\n  const { document } = value\n  change.normalizeNodeByKey(document.key)\n}\n\n/**\n * Normalize a `node` and its children with the value's schema.\n *\n * @param {Change} change\n * @param {Node|String} key\n */\n\nChanges.normalizeNodeByKey = (change, key) => {\n  const { value } = change\n  let { document, schema } = value\n  const node = document.assertNode(key)\n\n  normalizeNodeAndChildren(change, node, schema)\n\n  document = change.value.document\n  const ancestors = document.getAncestors(key)\n  if (!ancestors) return\n\n  ancestors.forEach(ancestor => {\n    if (change.value.document.getDescendant(ancestor.key)) {\n      normalizeNode(change, ancestor, schema)\n    }\n  })\n}\n\n/**\n * Normalize a `node` and its children with a `schema`.\n *\n * @param {Change} change\n * @param {Node} node\n * @param {Schema} schema\n */\n\nfunction normalizeNodeAndChildren(change, node, schema) {\n  if (node.object == 'text') {\n    normalizeNode(change, node, schema)\n    return\n  }\n\n  let child = node.getFirstInvalidDescendant(schema)\n  let path = change.value.document.getPath(node.key)\n  while (node && child) {\n    normalizeNodeAndChildren(change, child, schema)\n    node = change.value.document.refindNode(path, node.key)\n    if (!node) {\n      path = []\n      child = null\n    } else {\n      path = change.value.document.refindPath(path, node.key)\n      child = node.getFirstInvalidDescendant(schema)\n    }\n  }\n\n  // Normalize the node itself if it still exists.\n  if (node) {\n    normalizeNode(change, node, schema)\n  }\n}\n\n/**\n * Normalize a `node` with a `schema`, but not its children.\n *\n * @param {Change} change\n * @param {Node} node\n * @param {Schema} schema\n */\n\nfunction normalizeNode(change, node, schema) {\n  const max = schema.stack.plugins.length + 1\n  let iterations = 0\n\n  function iterate(c, n) {\n    const normalize = n.validate(schema)\n    if (!normalize) return\n\n    // Run the `normalize` function to fix the node.\n    let path = c.value.document.getPath(n.key)\n    normalize(c)\n\n    // Re-find the node reference, in case it was updated. If the node no longer\n    // exists, we're done for this branch.\n    n = c.value.document.refindNode(path, n.key)\n    if (!n) return\n\n    path = c.value.document.refindPath(path, n.key)\n\n    // Increment the iterations counter, and check to make sure that we haven't\n    // exceeded the max. Without this check, it's easy for the `validate` or\n    // `normalize` function of a schema rule to be written incorrectly and for\n    // an infinite invalid loop to occur.\n    iterations++\n\n    if (iterations > max) {\n      throw new Error(\n        'A schema rule could not be validated after sufficient iterations. This is usually due to a `rule.validate` or `rule.normalize` function of a schema being incorrectly written, causing an infinite loop.'\n      )\n    }\n\n    // Otherwise, iterate again.\n    iterate(c, n)\n  }\n\n  iterate(change, node)\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Changes\n","import AtCurrentRange from './at-current-range'\nimport AtRange from './at-range'\nimport ByKey from './by-key'\nimport OnHistory from './on-history'\nimport OnSelection from './on-selection'\nimport OnValue from './on-value'\nimport WithSchema from './with-schema'\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n  ...AtCurrentRange,\n  ...AtRange,\n  ...ByKey,\n  ...OnHistory,\n  ...OnSelection,\n  ...OnValue,\n  ...WithSchema,\n}\n","import Debug from 'debug'\n\nimport Operation from '../models/operation'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:operation:apply')\n\n/**\n * Applying functions.\n *\n * @type {Object}\n */\n\nconst APPLIERS = {\n  /**\n   * Add mark to text at `offset` and `length` in node by `path`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  add_mark(value, operation) {\n    const { path, offset, length, mark } = operation\n    let { document } = value\n    let node = document.assertPath(path)\n    node = node.addMark(offset, length, mark)\n    document = document.updateNode(node)\n    value = value.set('document', document)\n    return value\n  },\n\n  /**\n   * Insert a `node` at `index` in a node by `path`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  insert_node(value, operation) {\n    const { path, node } = operation\n    const index = path[path.length - 1]\n    const rest = path.slice(0, -1)\n    let { document } = value\n    let parent = document.assertPath(rest)\n    parent = parent.insertNode(index, node)\n    document = document.updateNode(parent)\n    value = value.set('document', document)\n    return value\n  },\n\n  /**\n   * Insert `text` at `offset` in node by `path`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  insert_text(value, operation) {\n    const { path, offset, text, marks } = operation\n    let { document, selection } = value\n    const { anchorKey, focusKey, anchorOffset, focusOffset } = selection\n    let node = document.assertPath(path)\n\n    // Update the document\n    node = node.insertText(offset, text, marks)\n    document = document.updateNode(node)\n\n    // Update the selection\n    if (anchorKey == node.key && anchorOffset >= offset) {\n      selection = selection.moveAnchor(text.length)\n    }\n    if (focusKey == node.key && focusOffset >= offset) {\n      selection = selection.moveFocus(text.length)\n    }\n\n    value = value.set('document', document).set('selection', selection)\n    return value\n  },\n\n  /**\n   * Merge a node at `path` with the previous node.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  merge_node(value, operation) {\n    const { path } = operation\n    const withPath = path\n      .slice(0, path.length - 1)\n      .concat([path[path.length - 1] - 1])\n    let { document, selection } = value\n    const one = document.assertPath(withPath)\n    const two = document.assertPath(path)\n    let parent = document.getParent(one.key)\n    const oneIndex = parent.nodes.indexOf(one)\n    const twoIndex = parent.nodes.indexOf(two)\n\n    // Perform the merge in the document.\n    parent = parent.mergeNode(oneIndex, twoIndex)\n    document = document.updateNode(parent)\n\n    // If the nodes are text nodes and the selection is inside the second node\n    // update it to refer to the first node instead.\n    if (one.object == 'text') {\n      const { anchorKey, anchorOffset, focusKey, focusOffset } = selection\n      let normalize = false\n\n      if (anchorKey == two.key) {\n        selection = selection.moveAnchorTo(\n          one.key,\n          one.text.length + anchorOffset\n        )\n        normalize = true\n      }\n\n      if (focusKey == two.key) {\n        selection = selection.moveFocusTo(\n          one.key,\n          one.text.length + focusOffset\n        )\n        normalize = true\n      }\n\n      if (normalize) {\n        selection = selection.normalize(document)\n      }\n    }\n\n    // Update the document and selection.\n    value = value.set('document', document).set('selection', selection)\n    return value\n  },\n\n  /**\n   * Move a node by `path` to `newPath`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  move_node(value, operation) {\n    const { path, newPath } = operation\n    const newIndex = newPath[newPath.length - 1]\n    const newParentPath = newPath.slice(0, -1)\n    const oldParentPath = path.slice(0, -1)\n    const oldIndex = path[path.length - 1]\n    let { document } = value\n    const node = document.assertPath(path)\n\n    // Remove the node from its current parent.\n    let parent = document.getParent(node.key)\n    parent = parent.removeNode(oldIndex)\n    document = document.updateNode(parent)\n\n    // Find the new target...\n    let target\n\n    // If the old path and the rest of the new path are the same, then the new\n    // target is the old parent.\n    if (\n      oldParentPath.every((x, i) => x === newParentPath[i]) &&\n      oldParentPath.length === newParentPath.length\n    ) {\n      target = parent\n    } else if (\n      oldParentPath.every((x, i) => x === newParentPath[i]) &&\n      oldIndex < newParentPath[oldParentPath.length]\n    ) {\n      // Otherwise, if the old path removal resulted in the new path being no longer\n      // correct, we need to decrement the new path at the old path's last index.\n      newParentPath[oldParentPath.length]--\n      target = document.assertPath(newParentPath)\n    } else {\n      // Otherwise, we can just grab the target normally...\n      target = document.assertPath(newParentPath)\n    }\n\n    // Insert the new node to its new parent.\n    target = target.insertNode(newIndex, node)\n    document = document.updateNode(target)\n    value = value.set('document', document)\n    return value\n  },\n\n  /**\n   * Remove mark from text at `offset` and `length` in node by `path`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  remove_mark(value, operation) {\n    const { path, offset, length, mark } = operation\n    let { document } = value\n    let node = document.assertPath(path)\n    node = node.removeMark(offset, length, mark)\n    document = document.updateNode(node)\n    value = value.set('document', document)\n    return value\n  },\n\n  /**\n   * Remove a node by `path`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  remove_node(value, operation) {\n    const { path } = operation\n    let { document, selection } = value\n    const { startKey, endKey } = selection\n    const node = document.assertPath(path)\n\n    // If the selection is set, check to see if it needs to be updated.\n    if (selection.isSet) {\n      const hasStartNode = node.hasNode(startKey)\n      const hasEndNode = node.hasNode(endKey)\n      const first = node.object == 'text' ? node : node.getFirstText() || node\n      const last = node.object == 'text' ? node : node.getLastText() || node\n      const prev = document.getPreviousText(first.key)\n      const next = document.getNextText(last.key)\n\n      // If the start point was in this node, update it to be just before/after.\n      if (hasStartNode) {\n        if (prev) {\n          selection = selection.moveStartTo(prev.key, prev.text.length)\n        } else if (next) {\n          selection = selection.moveStartTo(next.key, 0)\n        } else {\n          selection = selection.deselect()\n        }\n      }\n\n      // If the end point was in this node, update it to be just before/after.\n      if (selection.isSet && hasEndNode) {\n        if (prev) {\n          selection = selection.moveEndTo(prev.key, prev.text.length)\n        } else if (next) {\n          selection = selection.moveEndTo(next.key, 0)\n        } else {\n          selection = selection.deselect()\n        }\n      }\n\n      // If the selection wasn't deselected, normalize it.\n      if (selection.isSet) {\n        selection = selection.normalize(document)\n      }\n    }\n\n    // Remove the node from the document.\n    let parent = document.getParent(node.key)\n    const index = parent.nodes.indexOf(node)\n    parent = parent.removeNode(index)\n    document = document.updateNode(parent)\n\n    // Update the document and selection.\n    value = value.set('document', document).set('selection', selection)\n    return value\n  },\n\n  /**\n   * Remove `text` at `offset` in node by `path`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  remove_text(value, operation) {\n    const { path, offset, text } = operation\n    const { length } = text\n    const rangeOffset = offset + length\n    let { document, selection } = value\n    const { anchorKey, focusKey, anchorOffset, focusOffset } = selection\n    let node = document.assertPath(path)\n\n    if (anchorKey == node.key) {\n      if (anchorOffset >= rangeOffset) {\n        selection = selection.moveAnchor(-length)\n      } else if (anchorOffset > offset) {\n        selection = selection.moveAnchorTo(anchorKey, offset)\n      }\n    }\n\n    if (focusKey == node.key) {\n      if (focusOffset >= rangeOffset) {\n        selection = selection.moveFocus(-length)\n      } else if (focusOffset > offset) {\n        selection = selection.moveFocusTo(focusKey, offset)\n      }\n    }\n\n    node = node.removeText(offset, length)\n    document = document.updateNode(node)\n    value = value.set('document', document).set('selection', selection)\n    return value\n  },\n\n  /**\n   * Set `properties` on mark on text at `offset` and `length` in node by `path`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  set_mark(value, operation) {\n    const { path, offset, length, mark, properties } = operation\n    let { document } = value\n    let node = document.assertPath(path)\n    node = node.updateMark(offset, length, mark, properties)\n    document = document.updateNode(node)\n    value = value.set('document', document)\n    return value\n  },\n\n  /**\n   * Set `properties` on a node by `path`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  set_node(value, operation) {\n    const { path, properties } = operation\n    let { document } = value\n    let node = document.assertPath(path)\n    node = node.merge(properties)\n    document = document.updateNode(node)\n    value = value.set('document', document)\n    return value\n  },\n\n  /**\n   * Set `properties` on the selection.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  set_selection(value, operation) {\n    const { properties } = operation\n    const { anchorPath, focusPath, ...props } = properties\n    let { document, selection } = value\n\n    if (anchorPath !== undefined) {\n      props.anchorKey =\n        anchorPath === null ? null : document.assertPath(anchorPath).key\n    }\n\n    if (focusPath !== undefined) {\n      props.focusKey =\n        focusPath === null ? null : document.assertPath(focusPath).key\n    }\n\n    selection = selection.merge(props)\n    selection = selection.normalize(document)\n    value = value.set('selection', selection)\n    return value\n  },\n\n  /**\n   * Set `properties` on `value`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  set_value(value, operation) {\n    const { properties } = operation\n    value = value.merge(properties)\n    return value\n  },\n\n  /**\n   * Split a node by `path` at `offset`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  split_node(value, operation) {\n    const { path, position, properties } = operation\n    let { document, selection } = value\n\n    // Calculate a few things...\n    const node = document.assertPath(path)\n    let parent = document.getParent(node.key)\n    const index = parent.nodes.indexOf(node)\n\n    // Split the node by its parent.\n    parent = parent.splitNode(index, position)\n    if (properties) {\n      const splitNode = parent.nodes.get(index + 1)\n      if (splitNode.object !== 'text') {\n        parent = parent.updateNode(splitNode.merge(properties))\n      }\n    }\n    document = document.updateNode(parent)\n\n    // Determine whether we need to update the selection...\n    const { startKey, endKey, startOffset, endOffset } = selection\n    const next = document.getNextText(node.key)\n    let normalize = false\n\n    // If the start point is after or equal to the split, update it.\n    if (node.key == startKey && position <= startOffset) {\n      selection = selection.moveStartTo(next.key, startOffset - position)\n      normalize = true\n    }\n\n    // If the end point is after or equal to the split, update it.\n    if (node.key == endKey && position <= endOffset) {\n      selection = selection.moveEndTo(next.key, endOffset - position)\n      normalize = true\n    }\n\n    // Normalize the selection if we changed it, since the methods we use might\n    // leave it in a non-normalized value.\n    if (normalize) {\n      selection = selection.normalize(document)\n    }\n\n    // Return the updated value.\n    value = value.set('document', document).set('selection', selection)\n    return value\n  },\n}\n\n/**\n * Apply an `operation` to a `value`.\n *\n * @param {Value} value\n * @param {Object|Operation} operation\n * @return {Value} value\n */\n\nfunction applyOperation(value, operation) {\n  operation = Operation.create(operation)\n  const { type } = operation\n  const apply = APPLIERS[type]\n\n  if (!apply) {\n    throw new Error(`Unknown operation type: \"${type}\".`)\n  }\n\n  debug(type, operation)\n  value = apply(value, operation)\n  return value\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default applyOperation\n","import Debug from 'debug'\nimport isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport pick from 'lodash/pick'\nimport { List } from 'immutable'\n\nimport MODEL_TYPES, { isType } from '../constants/model-types'\nimport Changes from '../changes'\nimport Operation from './operation'\nimport apply from '../operations/apply'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:change')\n\n/**\n * Change.\n *\n * @type {Change}\n */\n\nclass Change {\n  /**\n   * Check if `any` is a `Change`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isChange = isType.bind(null, 'CHANGE')\n\n  /**\n   * Create a new `Change` with `attrs`.\n   *\n   * @param {Object} attrs\n   *   @property {Value} value\n   */\n\n  constructor(attrs) {\n    const { value } = attrs\n    this.value = value\n    this.operations = new List()\n    this.flags = {\n      normalize: true,\n      ...pick(attrs, ['merge', 'save', 'normalize']),\n    }\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'change'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Apply an `operation` to the current value, saving the operation to the\n   * history if needed.\n   *\n   * @param {Operation|Object} operation\n   * @param {Object} options\n   * @return {Change}\n   */\n\n  applyOperation(operation, options = {}) {\n    const { operations, flags } = this\n    let { value } = this\n    let { history } = value\n\n    // Add in the current `value` in case the operation was serialized.\n    if (isPlainObject(operation)) {\n      operation = { ...operation, value }\n    }\n\n    operation = Operation.create(operation)\n\n    // Default options to the change-level flags, this allows for setting\n    // specific options for all of the operations of a given change.\n    options = { ...flags, ...options }\n\n    // Derive the default option values.\n    const {\n      merge = operations.size == 0 ? null : true,\n      save = true,\n      skip = null,\n    } = options\n\n    // Apply the operation to the value.\n    debug('apply', { operation, save, merge })\n    value = apply(value, operation)\n\n    // If needed, save the operation to the history.\n    if (history && save) {\n      history = history.save(operation, { merge, skip })\n      value = value.set('history', history)\n    }\n\n    // Update the mutable change object.\n    this.value = value\n    this.operations = operations.push(operation)\n    return this\n  }\n\n  /**\n   * Apply a series of `operations` to the current value.\n   *\n   * @param {Array|List} operations\n   * @param {Object} options\n   * @return {Change}\n   */\n\n  applyOperations(operations, options) {\n    operations.forEach(op => this.applyOperation(op, options))\n    return this\n  }\n\n  /**\n   * Call a change `fn` with arguments.\n   *\n   * @param {Function} fn\n   * @param {Mixed} ...args\n   * @return {Change}\n   */\n\n  call(fn, ...args) {\n    fn(this, ...args)\n    return this\n  }\n\n  /**\n   * Applies a series of change mutations and defers normalization until the end.\n   *\n   * @param {Function} customChange - function that accepts a change object and executes change operations\n   * @return {Change}\n   */\n\n  withoutNormalization(customChange) {\n    const original = this.flags.normalize\n    this.setOperationFlag('normalize', false)\n    try {\n      customChange(this)\n      // if the change function worked then run normalization\n      this.normalizeDocument()\n    } finally {\n      // restore the flag to whatever it was\n      this.setOperationFlag('normalize', original)\n    }\n    return this\n  }\n\n  /**\n   * Set an operation flag by `key` to `value`.\n   *\n   * @param {String} key\n   * @param {Any} value\n   * @return {Change}\n   */\n\n  setOperationFlag(key, value) {\n    this.flags[key] = value\n    return this\n  }\n\n  /**\n   * Get the `value` of the specified flag by its `key`. Optionally accepts an `options`\n   * object with override flags.\n   *\n   * @param {String} key\n   * @param {Object} options\n   * @return {Change}\n   */\n\n  getFlag(key, options = {}) {\n    return options[key] !== undefined ? options[key] : this.flags[key]\n  }\n\n  /**\n   * Unset an operation flag by `key`.\n   *\n   * @param {String} key\n   * @return {Change}\n   */\n\n  unsetOperationFlag(key) {\n    delete this.flags[key]\n    return this\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nChange.prototype[MODEL_TYPES.CHANGE] = true\n\n/**\n * Add a change method for each of the changes.\n */\n\nObject.keys(Changes).forEach(type => {\n  Change.prototype[type] = function(...args) {\n    debug(type, { args })\n    this.call(Changes[type], ...args)\n    return this\n  }\n})\n\n/**\n * Export.\n *\n * @type {Change}\n */\n\nexport default Change\n","import apply from './apply'\nimport invert from './invert'\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n  apply,\n  invert,\n}\n","import Block from './models/block'\nimport Change from './models/change'\nimport Changes from './changes'\nimport Character from './models/character'\nimport Data from './models/data'\nimport Document from './models/document'\nimport History from './models/history'\nimport Inline from './models/inline'\nimport Leaf from './models/leaf'\nimport Mark from './models/mark'\nimport Node from './models/node'\nimport Operation from './models/operation'\nimport Operations from './operations'\nimport Range from './models/range'\nimport Schema from './models/schema'\nimport Stack from './models/stack'\nimport Text from './models/text'\nimport Value from './models/value'\nimport { resetKeyGenerator, setKeyGenerator } from './utils/generate-key'\nimport { resetMemoization, useMemoization } from './utils/memoize'\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport {\n  Block,\n  Change,\n  Changes,\n  Character,\n  Data,\n  Document,\n  History,\n  Inline,\n  Leaf,\n  Mark,\n  Node,\n  Operation,\n  Operations,\n  Range,\n  Schema,\n  Stack,\n  Text,\n  Value,\n  resetKeyGenerator,\n  setKeyGenerator,\n  resetMemoization,\n  useMemoization,\n}\n\nexport default {\n  Block,\n  Changes,\n  Character,\n  Data,\n  Document,\n  History,\n  Inline,\n  Leaf,\n  Mark,\n  Node,\n  Operation,\n  Operations,\n  Range,\n  Schema,\n  Stack,\n  Text,\n  Value,\n  resetKeyGenerator,\n  setKeyGenerator,\n  resetMemoization,\n  useMemoization,\n}\n"],"names":["MODEL_TYPES","isType","type","any","n","generate","generateKey","setKeyGenerator","func","resetKeyGenerator","DEFAULTS","Map","undefined","List","Block","options","object","isVoid","data","toJSON","nodes","toArray","map","preserveKeys","key","deprecate","some","child","isEmpty","getText","attrs","isBlock","isPlainObject","fromJSON","Error","isList","Array","isArray","list","create","block","createChildren","every","item","Record","fromJS","bind","prototype","BLOCK","Inline","isInline","elements","inline","INLINE","Data","isMap","ENABLED","CACHE_KEY","LEAF","UNDEFINED","UNSET","memoize","properties","property","original","args","apply","__cache_key","__cache","__cache_no_args","__proto__","takesArguments","length","cachedValue","keys","getIn","value","v","setIn","get","parent","set","resetMemoization","Number","MAX_SAFE_INTEGER","useMemoization","enabled","Mark","schema","__getComponent","isMark","Set","isSet","marks","props","mark","MARK","Changes","PROXY_TRANSFORMS","forEach","method","change","selection","methodAtRange","match","collapseToStart","collapseToEnd","setBlock","setBlocks","setInline","setInlines","addMark","document","isExpanded","addMarkAtRange","add","sel","select","getActiveMarksAtRange","addMarks","delete","deleteAtRange","insertBlock","insertBlockAtRange","node","getNode","collapseToEndOf","insertFragment","fragment","size","startText","endText","startInline","lastText","getLastText","lastInline","getClosestInline","firstChild","first","lastChild","last","getTexts","text","isAppending","hasEdgeAtStartOf","hasEdgeAtEndOf","isInserting","hasBlocks","insertFragmentAtRange","newTexts","filter","includes","newText","takeLast","collapseToStartOf","move","insertInline","insertInlineAtRange","insertText","getInsertMarksAtRange","insertTextAtRange","splitBlock","depth","splitBlockAtRange","removeMark","removeMarkAtRange","remove","toggleMark","exists","activeMarks","has","wrapText","prefix","suffix","wrapTextAtRange","isCollapsed","moveStart","moveEnd","isForward","flip","Document","isDocument","DOCUMENT","Range","anchorOffset","getFirst","anchorKey","getLast","start","end","hasAnchorIn","hasDescendant","focusKey","focusOffset","hasFocusIn","hasAnchorAtStartOf","hasAnchorAtEndOf","merge","isBackward","offset","moveAnchorOffsetTo","moveFocusOffsetTo","moveFocusTo","moveAnchorTo","range","moveAnchorToStartOf","moveFocusToEndOf","anchorOffsetType","focusOffsetType","warn","anchorNode","getDescendant","focusNode","getFirstText","anchorText","getTextAtOffset","getOffset","focusText","areDescendantsSorted","isFocused","m","isRange","anchorPath","focusPath","createSet","obj","RANGE","MOVE_METHODS","p","s","EDGE_METHODS","hasEdge","anchor","focus","ALIAS_METHODS","alias","Character","isCharacter","split","character","CHARACTER","Leaf","characters","createList","char","isLeaf","leaf","Text","index","i","union","decorations","startKey","endKey","startOffset","endOffset","hasStart","hasEnd","__getDecorations","getDecoratedCharacters","leaves","prevChar","prevLeaf","push","prevMarks","isSame","is","getActiveMarks","startCharacter","result","withMutations","c","intersect","x","getMarks","OrderedSet","array","getMarksAsArray","previousMark","concat","chars","slice","filterNot","getLeaves","r","newMark","validateNode","validate","reduce","string","isText","l","getCharacters","TEXT","Node","second","assertKey","getKeysAsArray","firstIndex","indexOf","secondIndex","getChild","descendant","path","getDescendantAtPath","iterator","matches","forEachDescendant","found","ret","hasChild","ancestors","find","getAncestors","unshift","getBlocksAsArray","isLeafBlock","getBlocksAtRangeAsArray","normalize","isUnset","startBlock","getClosestBlock","endBlock","blocks","getBlocksByTypeAsArray","flatMap","t","getTextsAtRange","rest","findLast","getClosest","one","two","assertDescendant","oneParent","getParent","twoParent","stack","startAt","getFurthestAncestor","getDepth","descendantFound","previous","position","splitNode","updateNode","getNextText","startNode","getNextSibling","endNode","startIndex","endIndex","getFurthest","shift","reverse","takeUntil","getInlinesAsArray","isLeafInline","getInlinesAtRangeAsArray","getTextsAtRangeAsArray","getInlinesByTypeAsArray","inlines","desc","getOrderedMarksAtRange","getMarksAtPosition","getOrderedMarksBetweenPositions","getMarksBetweenOffsets","texts","getTextsBetweenPositionsAsArray","toSet","getPreviousText","getActiveMarksBetweenOffsets","startMarks","endMarks","getMarksByTypeAsArray","next","after","skipUntil","memo","assertNode","ancestor","getPath","__getPlaceholder","before","isSelected","isBlurred","dir","direction","getTextsAsArray","getClosestVoid","regenerateKey","mapDescendants","insert","withIndex","removeNode","insertNode","findIndex","splice","befores","take","afters","skip","getFirstInvalidDescendant","isNode","kind","arg","Object","getOwnPropertyNames","SURROGATE_START","SURROGATE_END","SPACE","CHAMELEON","PUNCTUATION","isSurrogate","code","isWord","remaining","test","charAt","getCharLength","charCodeAt","getCharOffset","getCharOffsetBackward","getCharOffsetForward","getWordOffset","started","getWordOffsetBackward","o","getWordOffsetForward","getFlag","addMarkByKey","addMarksAtRange","snapshotSelection","isStartVoid","hasVoidParent","isEndVoid","isHanging","prevText","startVoid","nextText","removeNodeByKey","endVoid","removeTextByKey","startLength","endLength","getCommonAncestor","startChild","endChild","startParent","startParentIndex","endParentIndex","startChildIndex","endChildIndex","middles","lonely","getFurthestOnlyChildAncestor","moveNodeByKey","mergeNodeByKey","normalizeNodeByKey","deleteCharBackwardAtRange","String","deleteBackwardAtRange","deleteLineBackwardAtRange","deleteWordBackwardAtRange","voidParent","isAtStartOf","prev","prevBlock","prevVoid","traversed","deleteCharForwardAtRange","deleteForwardAtRange","deleteLineForwardAtRange","deleteWordForwardAtRange","nextBlock","getNextBlock","moveToStartOf","isAtEndOf","nextVoid","extra","insertNodeByKey","splitDescendantsByKey","collapseTo","isAtStart","getBlocks","firstBlock","lastBlock","lonelyParent","lonelyChild","removeDescendant","newIndex","nextChild","nextNodes","lastIndex","inlineChild","inlineIndex","splitNodeByKey","insertTextByKey","commonAncestor","normalizeAncestor","normalizeKey","removeMarkByKey","setBlocksAtRange","getBlocksAtRange","sets","setNodeByKey","setBlockAtRange","setInlinesAtRange","getInlinesAtRange","setInlineAtRange","height","h","splitInlineAtRange","Infinity","toggleMarkAtRange","equals","unwrapBlockAtRange","createProperties","wrappers","isSuperset","toOrderedSet","toList","children","b","firstMatch","lastMatch","firstText","normalizeDocument","unwrapInlineAtRange","wrapBlockAtRange","clear","firstblock","lastblock","siblings","p1","p2","indexes","ind","wrapInlineAtRange","inlineParent","wrapInlineByKey","startInner","startInnerIndex","endInner","startInlines","endInlines","operations","bx","by","ax","ay","Math","max","min","applyOperations","insertFragmentByKey","applyOperation","getMarksAtIndex","getPreviousSibling","newKey","newPath","removeAllMarksByKey","state","setTextByKey","textNode","replaceTextByKey","activeMark","removals","replaceNodeByKey","newNode","setMarkByKey","target","textKey","textOffset","a","prevIndex","unwrapInlineByKey","moveToRangeOf","unwrapBlockByKey","unwrapNodeByKey","isFirst","isLast","parentParent","parentIndex","wrapBlockByKey","wrapNodeByKey","OPERATION_ATTRIBUTES","debug","Debug","Stack","History","operation","history","undos","redos","prevBatch","peek","prevOperation","shouldSkip","shouldMerge","batch","pop","isHistory","HISTORY","isEqual","CORE_SCHEMA_RULES","invalids","objects","insertBefore","insertAfter","Boolean","plugins","plugin","getPluginsWith","reduceRight","STACK","Schema","parents","rule","violation","context","CHILD_OBJECT_INVALID","CHILD_TYPE_INVALID","CHILD_UNKNOWN","FIRST_CHILD_OBJECT_INVALID","FIRST_CHILD_TYPE_INVALID","LAST_CHILD_OBJECT_INVALID","LAST_CHILD_TYPE_INVALID","CHILD_REQUIRED","NODE_TEXT_INVALID","PARENT_INVALID","NODE_DATA_INVALID","NODE_IS_VOID_INVALID","NODE_MARK_INVALID","getRule","getParentRules","ctx","fail","fn","def","types","nextDef","defs","rewind","definedObjects","definedTypes","allowedObject","allowedType","allowed","isSchema","rules","resolveSchema","SCHEMA","d","resolveDocumentRule","bs","resolveNodeRule","customizer","source","Value","Change","preserveData","preserveDecorations","preserveHistory","preserveSelection","preserveSchema","getPreviousBlock","getNextInline","getPreviousInline","getCharactersAtRange","getMarksAtRange","getFragmentAtRange","isValue","save","VALUE","Operation","json","ATTRIBUTES","toJS","isOperation","OPERATION","invertOperation","op","inverse","inversePath","inverseNewPath","pathLast","newPathLast","e","inverseNode","inverseProperties","pick","inverseMark","assertPath","inverseSelection","inverseProps","inverseValue","redo","omit","undo","invert","snapshot","k","moved","hasOwnProperty","selectAll","moveAnchorCharBackward","anchorBlock","previousText","isInVoid","isPreviousInVoid","moveAnchor","moveAnchorToEndOf","hasNode","moveAnchorCharForward","isNextInVoid","moveFocusCharBackward","focusBlock","moveFocus","moveFocusCharForward","moveFocusToStartOf","MOVE_DIRECTIONS","collapse","PREFIXES","DIRECTIONS","OBJECTS","edges","edge","getDirectionNode","directionKey","setValue","normalizeNodeAndChildren","refindNode","refindPath","normalizeNode","iterations","iterate","AtCurrentRange","AtRange","ByKey","OnHistory","OnSelection","OnValue","WithSchema","APPLIERS","withPath","oneIndex","twoIndex","mergeNode","newParentPath","oldParentPath","oldIndex","hasStartNode","hasEndNode","moveStartTo","deselect","moveEndTo","rangeOffset","removeText","updateMark","flags","customChange","setOperationFlag","isChange","CHANGE","call"],"mappings":"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"}